use banking_es::{
    application::services::CQRSAccountService,
    infrastructure::{
        cdc_debezium::{CDCOutboxRepository, DebeziumConfig},
        cdc_service_manager::{CDCServiceManager, EnhancedCDCMetrics},
        init,
    },
};
use rust_decimal::Decimal;
use std::sync::Arc;
use tokio::time::{sleep, Duration};
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    println!("ğŸš€ Starting Simple CDC Pipeline Test");

    // Setup test environment using the same pattern as working_stress_test.rs
    println!("ğŸ”§ Initializing services using main.rs pattern...");
    let service_context = match init::init_all_services().await {
        Ok(ctx) => {
            println!("âœ… All services initialized successfully");
            ctx
        }
        Err(e) => {
            println!("âŒ Failed to initialize services: {:?}", e);
            return Err(e.into());
        }
    };

    // Create KafkaConfig instance (same as main.rs)
    let kafka_config = banking_es::infrastructure::kafka_abstraction::KafkaConfig::default();

    // Initialize CQRS service using the services from ServiceContext (same as main.rs)
    let cqrs_service = Arc::new(CQRSAccountService::new(
        service_context.event_store.clone(),
        service_context.projection_store.clone(),
        service_context.cache_service.clone(),
        kafka_config.clone(),
        1000,                      // max_concurrent_operations
        250,                       // batch_size
        Duration::from_millis(25), // batch_timeout
        true,                      // enable_write_batching
    ));

    // Start write batching service (same as main.rs)
    if let Err(e) = cqrs_service.start_write_batching().await {
        println!("âŒ Failed to start write batching: {:?}", e);
        return Err(e.into());
    }
    println!("âœ… Write batching service started");

    // Create CDC service manager (same as main.rs)
    println!("ğŸ”§ Setting up CDC service manager...");
    let cdc_outbox_repo = Arc::new(CDCOutboxRepository::new(
        service_context.event_store.get_partitioned_pools().clone(),
    ));

    let kafka_producer_for_cdc =
        match banking_es::infrastructure::kafka_abstraction::KafkaProducer::new(
            kafka_config.clone(),
        ) {
            Ok(producer) => producer,
            Err(e) => {
                println!("âŒ Failed to create Kafka producer: {:?}", e);
                return Err(e.into());
            }
        };

    let kafka_consumer_for_cdc =
        match banking_es::infrastructure::kafka_abstraction::KafkaConsumer::new(
            kafka_config.clone(),
        ) {
            Ok(consumer) => consumer,
            Err(e) => {
                println!("âŒ Failed to create Kafka consumer: {:?}", e);
                return Err(e.into());
            }
        };

    let cdc_config = DebeziumConfig::default();
    let metrics = Arc::new(EnhancedCDCMetrics::default());

    let mut cdc_service_manager = match CDCServiceManager::new(
        cdc_config,
        cdc_outbox_repo,
        kafka_producer_for_cdc,
        kafka_consumer_for_cdc,
        service_context.cache_service.clone(),
        service_context.projection_store.clone(),
        Some(metrics.clone()),
        Some(cqrs_service.get_consistency_manager()),
    ) {
        Ok(manager) => manager,
        Err(e) => {
            println!("âŒ Failed to create CDC service manager: {:?}", e);
            return Err(e.into());
        }
    };

    // Start CDC service (same as main.rs)
    println!("ğŸ”§ Starting CDC service manager...");
    if let Err(e) = cdc_service_manager.start().await {
        println!("âŒ Failed to start CDC service manager: {:?}", e);
        return Err(e.into());
    }
    println!("âœ… CDC Service Manager started");

    // Get the processor with batch processing enabled (same as main.rs)
    let processor = match cdc_service_manager.get_processor_with_batch_enabled().await {
        Ok(proc) => proc,
        Err(e) => {
            println!("âŒ Failed to get CDC processor: {:?}", e);
            return Err(e.into());
        }
    };
    println!("âœ… CDC Event Processor with batch processing enabled retrieved");

    // Verify batch processing is enabled (same as main.rs)
    let is_batch_running = processor.is_batch_processor_running().await;
    println!("âœ… CDC Batch Processor running: {}", is_batch_running);

    // Wait a moment for CDC to be ready
    println!("â³ Waiting for CDC to be ready...");
    sleep(Duration::from_secs(2)).await;

    // Create a single account
    println!("ğŸ”§ Creating test account...");
    let create_command = banking_es::application::cqrs::commands::CreateAccountCommand {
        owner_name: "Test User".to_string(),
        initial_balance: Decimal::new(1000, 0),
    };

    let account_id = match cqrs_service
        .create_account(create_command.owner_name, create_command.initial_balance)
        .await
    {
        Ok(id) => {
            println!("âœ… Account created successfully with ID: {}", id);
            id
        }
        Err(e) => {
            println!("âŒ Failed to create account: {:?}", e);
            return Err(e.into());
        }
    };

    // Wait for CDC to process the event
    println!("â³ Waiting for CDC to process the event...");
    println!("ğŸ” CDC Topic: banking-es.public.kafka_outbox_cdc");
    println!("ğŸ” Account ID: {}", account_id);
    sleep(Duration::from_secs(10)).await; // Increased wait time

    // Try to read the account
    println!("ğŸ” Attempting to read the account...");
    let read_result = cqrs_service.get_account(account_id).await;

    match read_result {
        Ok(account) => {
            println!("âœ… Successfully read account: {:?}", account);
            println!("âœ… Full CDC pipeline is working correctly!");
        }
        Err(e) => {
            println!("âŒ Failed to read account: {:?}", e);
            println!("âŒ CDC pipeline may not be working properly");
        }
    }

    // Cleanup
    println!("ğŸ§¹ Cleaning up...");
    if let Err(e) = cdc_service_manager.stop().await {
        println!("âš ï¸ Failed to stop CDC service manager: {:?}", e);
    }
    service_context.event_store.get_pool().close().await;
    println!("âœ… Cleanup completed");

    Ok(())
}
