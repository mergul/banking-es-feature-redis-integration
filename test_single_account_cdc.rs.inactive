use banking_es::{
    application::services::CQRSAccountService,
    infrastructure::{
        cdc_debezium::{CDCOutboxRepository, DebeziumConfig},
        cdc_service_manager::{CDCServiceManager, EnhancedCDCMetrics},
        init,
    },
};
use rust_decimal::Decimal;
use std::sync::Arc;
use std::time::Duration;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔧 Single Account Creation Test with CDC");
    println!("=========================================");

    // Set the database URL
    std::env::set_var(
        "DATABASE_URL",
        "postgresql://postgres:Francisco1@localhost:5432/banking_es",
    );

    // Initialize services
    let service_context = match banking_es::infrastructure::init::init_all_services().await {
        Ok(ctx) => {
            println!("✅ Services initialized");
            ctx
        }
        Err(e) => {
            println!("❌ Service initialization failed: {:?}", e);
            return Err(e.into());
        }
    };

    // Create CQRS service WITH write batching enabled
    let kafka_config = banking_es::infrastructure::kafka_abstraction::KafkaConfig::default();
    let cqrs_service = Arc::new(CQRSAccountService::new(
        service_context.event_store.clone(),
        service_context.projection_store.clone(),
        service_context.cache_service.clone(),
        kafka_config.clone(),
        5,  // Low concurrency
        10, // Small batch size
        Duration::from_millis(100),
        true, // ENABLE write batching to test CDC pipeline
    ));

    println!("✅ CQRS service created (write batching enabled)");

    // Set up CDC service manager
    let cdc_outbox_repo = Arc::new(CDCOutboxRepository::new(
        service_context.event_store.get_partitioned_pools().clone(),
    ));
    let kafka_producer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaProducer::new(kafka_config.clone())
            .expect("Failed to create Kafka producer");
    let kafka_consumer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaConsumer::new(kafka_config.clone())
            .expect("Failed to create Kafka consumer");

    let cdc_config = DebeziumConfig::default();
    let metrics = Arc::new(EnhancedCDCMetrics::default());

    let mut cdc_service_manager = CDCServiceManager::new(
        cdc_config,
        cdc_outbox_repo,
        kafka_producer_for_cdc,
        kafka_consumer_for_cdc,
        service_context.cache_service.clone(),
        service_context.projection_store.clone(),
        Some(metrics.clone()),
        Some(cqrs_service.get_consistency_manager()),
    )
    .expect("Failed to create CDC service manager");

    // Start CDC service
    println!("🔧 Starting CDC service manager...");
    match tokio::time::timeout(Duration::from_secs(30), cdc_service_manager.start()).await {
        Ok(Ok(_)) => {
            println!("✅ CDC Service Manager started");
        }
        Ok(Err(e)) => {
            println!("❌ Failed to start CDC service: {:?}", e);
            return Err(e.into());
        }
        Err(_) => {
            println!("❌ CDC service manager start timed out after 30 seconds");
            return Err("CDC service timeout".into());
        }
    }

    // Test 1: Create account
    println!("\n📝 Test 1: Create Account");
    let account_id = match cqrs_service
        .create_account("CDCTestUser".to_string(), Decimal::new(1000, 0))
        .await
    {
        Ok(id) => {
            println!("✅ Account created: {}", id);
            id
        }
        Err(e) => {
            println!("❌ Failed to create account: {:?}", e);
            return Err(e.into());
        }
    };

    // Test 2: Wait for CDC to process and try to read the account
    println!("\n📖 Test 2: Wait for CDC and Read Account");
    println!("⏳ Waiting for CDC to process...");
    tokio::time::sleep(Duration::from_secs(5)).await;

    match cqrs_service.get_account(account_id).await {
        Ok(Some(account)) => {
            println!("✅ Successfully read account: {:?}", account);
        }
        Ok(None) => {
            println!("❌ Account not found in projection");
        }
        Err(e) => {
            println!("❌ Error reading account: {:?}", e);
        }
    }

    // Test 3: Check projection table directly
    println!("\n🔍 Test 3: Check Projection Table Directly");
    match service_context
        .projection_store
        .get_account(account_id)
        .await
    {
        Ok(Some(projection)) => {
            println!("✅ Found account in projection table:");
            println!("   Account ID: {}", projection.id);
            println!("   Owner Name: {}", projection.owner_name);
            println!("   Balance: {}", projection.balance);
            println!("   Is Active: {}", projection.is_active);
            println!("   Created At: {}", projection.created_at);
            println!("   Updated At: {}", projection.updated_at);
        }
        Ok(None) => {
            println!("❌ Account not found in projection table");
        }
        Err(e) => {
            println!("❌ Error querying projection table: {:?}", e);
        }
    }

    // Test 4: Check CDC metrics
    println!("\n📊 Test 4: CDC Metrics");
    let cdc_metrics = cdc_service_manager.get_metrics();
    println!(
        "   Events Processed: {}",
        cdc_metrics
            .events_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Projection Updates: {}",
        cdc_metrics
            .projection_updates
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Batches Processed: {}",
        cdc_metrics
            .batches_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );

    println!("\n🎯 Test completed!");
    Ok(())
}
