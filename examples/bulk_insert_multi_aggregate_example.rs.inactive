use banking_es::domain::{Account, AccountEvent};
use banking_es::infrastructure::{
    event_store::{EventStore, EventStoreTrait},
    projections::ProjectionStore,
    write_batching::{PartitionedBatching, WriteOperation},
};
use rust_decimal::Decimal;
use std::sync::Arc;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize event store and projection store
    let event_store = Arc::new(EventStore::new(
        sqlx::PgPool::connect("postgresql://user:pass@localhost/banking_es").await?,
    ));
    let projection_store = Arc::new(
        ProjectionStore::new(banking_es::infrastructure::projections::ProjectionConfig::default())
            .await?,
    );

    // Create write pool (simplified for example)
    let write_pool =
        Arc::new(sqlx::PgPool::connect("postgresql://user:pass@localhost/banking_es").await?);

    // Create outbox batcher
    let outbox_batcher = banking_es::infrastructure::cdc_debezium::OutboxBatcher::new_default(
        Arc::new(
            banking_es::infrastructure::cdc_debezium::CDCOutboxRepository::new(
                event_store.get_partitioned_pools().clone(),
            ),
        ),
        event_store.get_partitioned_pools().clone(),
    );

    // Initialize partitioned batching
    let batching = PartitionedBatching::new(
        event_store.clone(),
        projection_store.clone(),
        write_pool.clone(),
        outbox_batcher,
    )
    .await;

    println!("ğŸš€ Bulk insert multi-aggregate sistemi baÅŸlatÄ±ldÄ±");

    // Ã–rnek 1: Direkt bulk_insert_events_multi_aggregate kullanÄ±mÄ±
    println!("\nğŸ“ Ã–rnek 1: Direkt bulk_insert_events_multi_aggregate kullanÄ±mÄ±");

    // Birden fazla aggregate iÃ§in event'ler hazÄ±rla
    let mut events_by_aggregate = Vec::new();

    // Aggregate 1: Hesap oluÅŸturma
    let account_id_1 = Uuid::new_v4();
    let events_1 = vec![
        AccountEvent::AccountCreated {
            account_id: account_id_1,
            owner_name: "Ahmet YÄ±lmaz".to_string(),
            initial_balance: Decimal::new(1000, 0),
        },
        AccountEvent::MoneyDeposited {
            account_id: account_id_1,
            amount: Decimal::new(500, 0),
            transaction_id: Uuid::new_v4(),
        },
    ];
    events_by_aggregate.push((account_id_1, events_1, Some(0))); // partition 0

    // Aggregate 2: Hesap oluÅŸturma
    let account_id_2 = Uuid::new_v4();
    let events_2 = vec![
        AccountEvent::AccountCreated {
            account_id: account_id_2,
            owner_name: "Fatma Demir".to_string(),
            initial_balance: Decimal::new(2000, 0),
        },
        AccountEvent::MoneyDeposited {
            account_id: account_id_2,
            amount: Decimal::new(300, 0),
            transaction_id: Uuid::new_v4(),
        },
        AccountEvent::MoneyWithdrawn {
            account_id: account_id_2,
            amount: Decimal::new(100, 0),
            transaction_id: Uuid::new_v4(),
        },
    ];
    events_by_aggregate.push((account_id_2, events_2, Some(1))); // partition 1

    // Aggregate 3: Sadece para yatÄ±rma
    let account_id_3 = Uuid::new_v4();
    let events_3 = vec![AccountEvent::MoneyDeposited {
        account_id: account_id_3,
        amount: Decimal::new(750, 0),
        transaction_id: Uuid::new_v4(),
    }];
    events_by_aggregate.push((account_id_3, events_3, Some(2))); // partition 2

    println!(
        "ğŸ”„ {} aggregate iÃ§in {} event bulk insert ediliyor...",
        events_by_aggregate.len(),
        events_by_aggregate
            .iter()
            .map(|(_, events, _)| events.len())
            .sum::<usize>()
    );

    let start_time = std::time::Instant::now();

    // Bulk insert iÅŸlemini baÅŸlat
    let mut transaction = write_pool.begin().await?;

    let result = event_store
        .save_events_multi_aggregate_in_transaction(&mut transaction, events_by_aggregate)
        .await;

    match result {
        Ok(_) => {
            transaction.commit().await?;
            let duration = start_time.elapsed();
            println!("âœ… Bulk insert baÅŸarÄ±yla tamamlandÄ±! SÃ¼re: {:?}", duration);
        }
        Err(e) => {
            transaction.rollback().await?;
            println!("âŒ Bulk insert baÅŸarÄ±sÄ±z: {}", e);
            return Err(e.into());
        }
    }

    // Ã–rnek 2: BÃ¼yÃ¼k Ã¶lÃ§ekli bulk insert
    println!("\nğŸ“Š Ã–rnek 2: BÃ¼yÃ¼k Ã¶lÃ§ekli bulk insert (1000 aggregate)");

    let mut large_events_by_aggregate = Vec::new();

    for i in 0..1000 {
        let account_id = Uuid::new_v4();
        let partition = i % 8; // 8 partition'a daÄŸÄ±t

        let events = vec![
            AccountEvent::AccountCreated {
                account_id,
                owner_name: format!("KullanÄ±cÄ±_{}", i),
                initial_balance: Decimal::new(1000 + (i as i64 * 10), 0),
            },
            AccountEvent::MoneyDeposited {
                account_id,
                amount: Decimal::new(100 + (i as i64), 0),
                transaction_id: Uuid::new_v4(),
            },
        ];

        large_events_by_aggregate.push((account_id, events, Some(partition)));
    }

    println!(
        "ğŸ”„ 1000 aggregate iÃ§in {} event bulk insert ediliyor...",
        large_events_by_aggregate.len() * 2
    );

    let start_time_large = std::time::Instant::now();

    let mut transaction_large = write_pool.begin().await?;

    let result_large = event_store
        .save_events_multi_aggregate_in_transaction(
            &mut transaction_large,
            large_events_by_aggregate,
        )
        .await;

    match result_large {
        Ok(_) => {
            transaction_large.commit().await?;
            let duration = start_time_large.elapsed();
            println!("âœ… BÃ¼yÃ¼k Ã¶lÃ§ekli bulk insert baÅŸarÄ±yla tamamlandÄ±!");
            println!(
                "ğŸ“ˆ Performans: {} aggregate/saniye",
                1000.0 / duration.as_secs_f64()
            );
        }
        Err(e) => {
            transaction_large.rollback().await?;
            println!("âŒ BÃ¼yÃ¼k Ã¶lÃ§ekli bulk insert baÅŸarÄ±sÄ±z: {}", e);
            return Err(e.into());
        }
    }

    // Ã–rnek 3: Bulk config ile birlikte kullanÄ±m
    println!("\nâš™ï¸ Ã–rnek 3: Bulk config ile birlikte kullanÄ±m");

    // Bulk modu baÅŸlat
    batching.start_bulk_mode_all_partitions().await?;
    println!("ğŸ”„ Bulk mod aktif");

    // Bulk insert iÅŸlemi
    let mut mixed_events = Vec::new();

    for i in 0..100 {
        let account_id = Uuid::new_v4();
        let partition = i % 4;

        let events = vec![AccountEvent::AccountCreated {
            account_id,
            owner_name: format!("Bulk_KullanÄ±cÄ±_{}", i),
            initial_balance: Decimal::new(500 + (i as i64 * 5), 0),
        }];

        mixed_events.push((account_id, events, Some(partition)));
    }

    let mut transaction_mixed = write_pool.begin().await?;

    let result_mixed = event_store
        .save_events_multi_aggregate_in_transaction(&mut transaction_mixed, mixed_events)
        .await;

    match result_mixed {
        Ok(_) => {
            transaction_mixed.commit().await?;
            println!("âœ… Bulk config ile bulk insert baÅŸarÄ±lÄ±!");
        }
        Err(e) => {
            transaction_mixed.rollback().await?;
            println!("âŒ Bulk config ile bulk insert baÅŸarÄ±sÄ±z: {}", e);
        }
    }

    // Bulk modu sonlandÄ±r
    batching.end_bulk_mode_all_partitions().await?;
    println!("ğŸ”„ Bulk mod sonlandÄ±rÄ±ldÄ±");

    println!("\nğŸ‰ TÃ¼m bulk insert iÅŸlemleri baÅŸarÄ±yla tamamlandÄ±!");
    println!("ğŸ“ˆ Sistem Ã¶zellikleri:");
    println!("   - Multi-aggregate event insert");
    println!("   - Partition bazlÄ± daÄŸÄ±tÄ±m");
    println!("   - Transaction gÃ¼venliÄŸi");
    println!("   - Bulk config optimizasyonu");

    Ok(())
}
