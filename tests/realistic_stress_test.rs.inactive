// use banking_es::{
//     application::services::CQRSAccountService,
//     infrastructure::{
//         cache_service::{CacheConfig, CacheService},
//         event_store::EventStore,
//         kafka_abstraction::KafkaConfig,
//         projections::ProjectionStore,
//         redis_abstraction::RealRedisClient,
//     },
// };
// use rust_decimal::Decimal;
// use sqlx::PgPool;
// use std::sync::Arc;
// use std::time::{Duration, Instant};
// use uuid::Uuid;

// #[derive(Debug)]
// struct StressTestResult {
//     total_operations: usize,
//     successful_operations: usize,
//     failed_operations: usize,
//     total_duration: Duration,
//     operations_per_second: f64,
//     success_rate: f64,
//     avg_latency: Duration,
//     p95_latency: Duration,
//     p99_latency: Duration,
//     min_latency: Duration,
//     max_latency: Duration,
//     batch_processing_metrics: BatchMetrics,
// }

// #[derive(Debug)]
// struct BatchMetrics {
//     accounts_created: usize,
//     deposits_made: usize,
//     withdrawals_made: usize,
//     reads_successful: usize,
//     reads_failed: usize,
//     final_total_balance: Decimal,
//     final_account_count: usize,
// }

// #[tokio::test]
// async fn test_realistic_batch_stress() {
//     println!("üöÄ Starting Realistic Batch Processing Stress Test");

//     // Setup database connection with optimized settings
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services with optimized configuration
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig {
//         default_ttl: Duration::from_secs(300), // 5 minutes
//         max_size: 1000,                        // Conservative cache size
//         shard_count: 16,                       // Reduced shard count
//         warmup_batch_size: 50,                 // Smaller warmup batches
//         ..Default::default()
//     };
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Setup CQRS service with write batching enabled
//     let kafka_config = KafkaConfig::default();
//     let cqrs_service = Arc::new(CQRSAccountService::new(
//         event_store.clone(),
//         projection_store.clone(),
//         cache_service.clone(),
//         kafka_config,
//         50,                     // Conservative max connections
//         25,                     // Conservative batch size
//         Duration::from_secs(2), // Conservative batch timeout
//         true,                   // Enable write batching
//     ));

//     // Start write batching service
//     cqrs_service
//         .start_write_batching()
//         .await
//         .expect("Failed to start write batching service");

//     println!("‚úÖ Services initialized with optimized configuration");

//     // Phase 1: Create accounts with proper waiting for batch processing
//     println!("\nüìä Phase 1: Account Creation");
//     let account_count = 50;
//     let account_ids = create_accounts_with_batch_waiting(&cqrs_service, account_count).await;
//     println!("‚úÖ Created {} accounts successfully", account_ids.len());

//     // Phase 2: Perform mixed operations with retries for eventual consistency
//     println!("\nüìä Phase 2: Mixed Operations");
//     let result = run_mixed_operations_with_retries(&cqrs_service, &account_ids, 300, 10).await;

//     // Phase 3: Verify final state
//     println!("\nüìä Phase 3: Final Verification");
//     let final_metrics = verify_final_state(&cqrs_service).await;

//     // Print comprehensive results
//     println!("\nüìà REALISTIC STRESS TEST RESULTS");
//     println!("=================================");
//     println!("  - Total Operations: {}", result.total_operations);
//     println!("  - Successful: {}", result.successful_operations);
//     println!("  - Failed: {}", result.failed_operations);
//     println!("  - Success Rate: {:.2}%", result.success_rate * 100.0);
//     println!("  - Duration: {:?}", result.total_duration);
//     println!("  - Ops/sec: {:.2}", result.operations_per_second);
//     println!("  - Avg Latency: {:?}", result.avg_latency);
//     println!("  - P95 Latency: {:?}", result.p95_latency);
//     println!("  - P99 Latency: {:?}", result.p99_latency);
//     println!("  - Min Latency: {:?}", result.min_latency);
//     println!("  - Max Latency: {:?}", result.max_latency);

//     println!("\nüìä BATCH PROCESSING METRICS");
//     println!("===========================");
//     println!(
//         "  - Accounts Created: {}",
//         result.batch_processing_metrics.accounts_created
//     );
//     println!(
//         "  - Deposits Made: {}",
//         result.batch_processing_metrics.deposits_made
//     );
//     println!(
//         "  - Withdrawals Made: {}",
//         result.batch_processing_metrics.withdrawals_made
//     );
//     println!(
//         "  - Reads Successful: {}",
//         result.batch_processing_metrics.reads_successful
//     );
//     println!(
//         "  - Reads Failed: {}",
//         result.batch_processing_metrics.reads_failed
//     );
//     println!(
//         "  - Final Total Balance: {}",
//         result.batch_processing_metrics.final_total_balance
//     );
//     println!(
//         "  - Final Account Count: {}",
//         result.batch_processing_metrics.final_account_count
//     );

//     println!("‚úÖ Realistic batch processing stress test completed successfully!");
// }

// async fn create_accounts_with_batch_waiting(
//     cqrs_service: &Arc<CQRSAccountService>,
//     count: usize,
// ) -> Vec<Uuid> {
//     let mut account_ids = Vec::new();

//     for i in 0..count {
//         let owner_name = format!("StressTestUser_{}", i);
//         let initial_balance = Decimal::new(1000, 0);

//         match cqrs_service
//             .create_account(owner_name, initial_balance)
//             .await
//         {
//             Ok(account_id) => {
//                 account_ids.push(account_id);
//             }
//             Err(e) => {
//                 println!("‚ö†Ô∏è  Failed to create account {}: {:?}", i, e);
//             }
//         }
//     }

//     // Wait for batch processing to complete
//     println!("‚è≥ Waiting for batch processing to complete account creation...");
//     tokio::time::sleep(Duration::from_secs(5)).await;

//     // Verify accounts are available
//     let mut verified_accounts = 0;
//     for &account_id in &account_ids {
//         if let Ok(Some(_)) = cqrs_service.get_account(account_id).await {
//             verified_accounts += 1;
//         }
//     }

//     println!(
//         "‚úÖ Verified {}/{} accounts are available after batch processing",
//         verified_accounts,
//         account_ids.len()
//     );

//     account_ids
// }

// async fn run_mixed_operations_with_retries(
//     cqrs_service: &Arc<CQRSAccountService>,
//     account_ids: &[Uuid],
//     total_ops: usize,
//     worker_count: usize,
// ) -> StressTestResult {
//     let start_time = Instant::now();

//     // Calculate operations per worker
//     let ops_per_worker = total_ops / worker_count;
//     let remaining_ops = total_ops % worker_count;

//     // Spawn worker tasks
//     let mut handles = Vec::new();
//     let (tx, mut rx) = tokio::sync::mpsc::channel(total_ops);

//     for worker_id in 0..worker_count {
//         let cqrs_service = cqrs_service.clone();
//         let account_ids = account_ids.to_vec();
//         let tx = tx.clone();

//         // Distribute remaining operations to first few workers
//         let worker_ops = ops_per_worker + if worker_id < remaining_ops { 1 } else { 0 };

//         let handle = tokio::spawn(async move {
//             run_worker_with_retries(worker_id, &cqrs_service, &account_ids, worker_ops, tx).await;
//         });

//         handles.push(handle);
//     }

//     // Collect results
//     let mut latencies = Vec::new();
//     let mut successful_ops = 0;
//     let mut failed_ops = 0;

//     for _ in 0..total_ops {
//         if let Some((latency, success)) = rx.recv().await {
//             latencies.push(latency);
//             if success {
//                 successful_ops += 1;
//             } else {
//                 failed_ops += 1;
//             }
//         }
//     }

//     // Wait for all workers to complete
//     for handle in handles {
//         let _ = handle.await;
//     }

//     let total_duration = start_time.elapsed();

//     // Calculate statistics
//     latencies.sort();
//     let avg_latency = if !latencies.is_empty() {
//         let total: Duration = latencies.iter().sum();
//         total / latencies.len() as u32
//     } else {
//         Duration::ZERO
//     };

//     let p95_index = (latencies.len() as f64 * 0.95) as usize;
//     let p99_index = (latencies.len() as f64 * 0.99) as usize;

//     let p95_latency = latencies.get(p95_index).copied().unwrap_or(Duration::ZERO);
//     let p99_latency = latencies.get(p99_index).copied().unwrap_or(Duration::ZERO);
//     let min_latency = latencies.first().copied().unwrap_or(Duration::ZERO);
//     let max_latency = latencies.last().copied().unwrap_or(Duration::ZERO);

//     let operations_per_second = total_ops as f64 / total_duration.as_secs_f64();
//     let success_rate = if total_ops > 0 {
//         successful_ops as f64 / total_ops as f64
//     } else {
//         0.0
//     };

//     // Get final metrics
//     let final_metrics = verify_final_state(cqrs_service).await;

//     StressTestResult {
//         total_operations: total_ops,
//         successful_operations: successful_ops,
//         failed_operations: failed_ops,
//         total_duration,
//         operations_per_second,
//         success_rate,
//         avg_latency,
//         p95_latency,
//         p99_latency,
//         min_latency,
//         max_latency,
//         batch_processing_metrics: final_metrics,
//     }
// }

// async fn run_worker_with_retries(
//     worker_id: usize,
//     cqrs_service: &Arc<CQRSAccountService>,
//     account_ids: &[Uuid],
//     operations: usize,
//     tx: tokio::sync::mpsc::Sender<(Duration, bool)>,
// ) {
//     for op_num in 0..operations {
//         let account_id = account_ids[op_num % account_ids.len()];
//         let start_time = Instant::now();

//         // Determine operation type
//         let operation_result = match op_num % 4 {
//             0 => {
//                 // Read operation - get account
//                 cqrs_service.get_account(account_id).await.map(|_| ())
//             }
//             1 => {
//                 // Read operation - get balance
//                 cqrs_service
//                     .get_account_balance(account_id)
//                     .await
//                     .map(|_| ())
//             }
//             2 => {
//                 // Write operation - deposit
//                 cqrs_service
//                     .deposit_money(account_id, Decimal::new(10, 0))
//                     .await
//             }
//             _ => {
//                 // Write operation - withdraw
//                 cqrs_service
//                     .withdraw_money(account_id, Decimal::new(5, 0))
//                     .await
//             }
//         };

//         let latency = start_time.elapsed();
//         let success = operation_result.is_ok();

//         // Send result
//         let _ = tx.send((latency, success)).await;

//         // Small delay to prevent overwhelming
//         if op_num % 10 == 0 {
//             tokio::time::sleep(Duration::from_millis(5)).await;
//         }
//     }
// }

// async fn verify_final_state(cqrs_service: &Arc<CQRSAccountService>) -> BatchMetrics {
//     // Get all accounts
//     let accounts = match cqrs_service.get_all_accounts().await {
//         Ok(accounts) => accounts,
//         Err(e) => {
//             println!("‚ùå Error getting accounts: {:?}", e);
//             return BatchMetrics {
//                 accounts_created: 0,
//                 deposits_made: 0,
//                 withdrawals_made: 0,
//                 reads_successful: 0,
//                 reads_failed: 0,
//                 final_total_balance: Decimal::ZERO,
//                 final_account_count: 0,
//             };
//         }
//     };

//     let mut total_balance = Decimal::ZERO;
//     let mut active_accounts = 0;

//     for account in &accounts {
//         if account.is_active {
//             active_accounts += 1;
//             total_balance += account.balance;
//         }
//     }

//     println!("‚úÖ Final state verification:");
//     println!("  - Total accounts: {}", accounts.len());
//     println!("  - Active accounts: {}", active_accounts);
//     println!("  - Total balance: {}", total_balance);

//     if active_accounts > 0 {
//         println!(
//             "  - Average balance: {}",
//             total_balance / Decimal::new(active_accounts as i64, 0)
//         );
//     }

//     BatchMetrics {
//         accounts_created: accounts.len(),
//         deposits_made: 0,    // Would need to track this separately
//         withdrawals_made: 0, // Would need to track this separately
//         reads_successful: 0, // Would need to track this separately
//         reads_failed: 0,     // Would need to track this separately
//         final_total_balance: total_balance,
//         final_account_count: active_accounts,
//     }
// }
