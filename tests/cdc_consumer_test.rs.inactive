use banking_es::{
    application::services::CQRSAccountService,
    infrastructure::{
        cdc_debezium::{CDCOutboxRepository, DebeziumConfig},
        cdc_service_manager::{CDCServiceManager, EnhancedCDCMetrics},
        init,
    },
};
use rust_decimal::Decimal;
use std::sync::Arc;
use std::time::Duration;
use uuid::Uuid;

#[tokio::test]
async fn test_cdc_consumer_processing() {
    println!("ğŸ”§ CDC Consumer Processing Test");
    println!("===============================");

    // Initialize services
    let service_context = match banking_es::infrastructure::init::init_all_services().await {
        Ok(ctx) => {
            println!("âœ… Services initialized");
            ctx
        }
        Err(e) => {
            println!("âŒ Service initialization failed: {:?}", e);
            return;
        }
    };

    // Create CQRS service with write batching enabled
    let kafka_config = banking_es::infrastructure::kafka_abstraction::KafkaConfig::default();
    let cqrs_service = Arc::new(CQRSAccountService::new(
        service_context.event_store.clone(),
        service_context.projection_store.clone(),
        service_context.cache_service.clone(),
        kafka_config.clone(),
        5,  // Low concurrency
        10, // Small batch size
        Duration::from_millis(50),
        true, // ENABLE write batching
    ));

    // Start write batching service
    cqrs_service
        .start_write_batching()
        .await
        .expect("Failed to start write batching");
    println!("âœ… CQRS service created with write batching enabled");

    // Get the consistency manager from CQRS service
    let consistency_manager = cqrs_service.get_consistency_manager();
    println!("âœ… Got consistency manager from CQRS service");

    // Create and start CDC service manager
    println!("ğŸ”§ Setting up CDC service manager...");
    let cdc_outbox_repo = Arc::new(CDCOutboxRepository::new(
        service_context.event_store.get_partitioned_pools().clone(),
    ));

    let kafka_producer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaProducer::new(kafka_config.clone())
            .expect("Failed to create Kafka producer");
    let kafka_consumer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaConsumer::new(kafka_config.clone())
            .expect("Failed to create Kafka consumer");

    let cdc_config = DebeziumConfig::default();
    let metrics = Arc::new(EnhancedCDCMetrics::default());

    let mut cdc_service_manager = CDCServiceManager::new(
        cdc_config,
        cdc_outbox_repo,
        kafka_producer_for_cdc,
        kafka_consumer_for_cdc,
        service_context.cache_service.clone(),
        service_context.projection_store.clone(),
        Some(metrics.clone()),
        Some(consistency_manager.clone()),
    )
    .expect("Failed to create CDC service manager");

    // Start CDC service
    println!("ğŸ”§ Starting CDC service manager...");
    match tokio::time::timeout(Duration::from_secs(30), cdc_service_manager.start()).await {
        Ok(Ok(_)) => {
            println!("âœ… CDC Service Manager started");
        }
        Ok(Err(e)) => {
            println!("âŒ Failed to start CDC service: {:?}", e);
            return;
        }
        Err(_) => {
            println!("âŒ CDC service manager start timed out after 30 seconds");
            return;
        }
    }

    // Get the processor to check if batch processing is enabled
    let processor = cdc_service_manager.processor_arc();
    println!("âœ… Got CDC processor");

    // Check if batch processor is running
    let is_batch_running = processor.is_batch_processor_running().await;
    println!("ğŸ“Š Batch processor running: {}", is_batch_running);

    // Test 1: Create account and check if event is processed
    println!("\nğŸ“ Test 1: Create Account and Check Event Processing");
    let account_id = match cqrs_service
        .create_account("ConsumerTestUser".to_string(), Decimal::new(1000, 0))
        .await
    {
        Ok(id) => {
            println!("âœ… Account created: {}", id);
            id
        }
        Err(e) => {
            println!("âŒ Failed to create account: {:?}", e);
            return;
        }
    };

    // Check initial metrics
    println!("ğŸ“Š Initial CDC Metrics:");
    let initial_metrics = cdc_service_manager.get_metrics();
    println!(
        "  Events Processed: {}",
        initial_metrics
            .events_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "  Projection Updates: {}",
        initial_metrics
            .projection_updates
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "  Batches Processed: {}",
        initial_metrics
            .batches_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );

    // Wait for CDC to process the event
    println!("â³ Waiting for CDC to process account creation...");
    for i in 1..=20 {
        tokio::time::sleep(Duration::from_secs(1)).await;
        println!("  Checking... {}s", i);

        // Check metrics
        let current_metrics = cdc_service_manager.get_metrics();
        let events_processed = current_metrics
            .events_processed
            .load(std::sync::atomic::Ordering::Relaxed);
        let projection_updates = current_metrics
            .projection_updates
            .load(std::sync::atomic::Ordering::Relaxed);
        let batches_processed = current_metrics
            .batches_processed
            .load(std::sync::atomic::Ordering::Relaxed);

        println!("    Events Processed: {}", events_processed);
        println!("    Projection Updates: {}", projection_updates);
        println!("    Batches Processed: {}", batches_processed);

        // Check consistency manager status
        let cdc_status = consistency_manager.get_status(account_id).await;
        let projection_status = consistency_manager.get_projection_status(account_id).await;
        println!("    CDC Status: {:?}", cdc_status);
        println!("    Projection Status: {:?}", projection_status);

        // If projection is completed, try to read the account
        if projection_status
            == Some(banking_es::infrastructure::consistency_manager::ProjectionStatus::Completed)
        {
            println!("âœ… Projection marked as completed!");
            match cqrs_service.get_account(account_id).await {
                Ok(Some(account)) => {
                    println!(
                        "âœ… Success! Found account: {} (balance: {})",
                        account.owner_name, account.balance
                    );
                    break;
                }
                Ok(None) => {
                    println!("âš ï¸ Projection completed but account not found in projections");
                }
                Err(e) => {
                    println!("âŒ Error reading account: {:?}", e);
                }
            }
        }

        // If we've processed events but projection is not completed, there's an issue
        if events_processed > 0
            && projection_status
                != Some(
                    banking_es::infrastructure::consistency_manager::ProjectionStatus::Completed,
                )
        {
            println!("âš ï¸ Events processed but projection not marked as completed");
        }
    }

    // Final metrics check
    println!("\nğŸ“Š Final CDC Metrics:");
    let final_metrics = cdc_service_manager.get_metrics();
    println!(
        "  Events Processed: {}",
        final_metrics
            .events_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "  Events Failed: {}",
        final_metrics
            .events_failed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "  Projection Updates: {}",
        final_metrics
            .projection_updates
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "  Batches Processed: {}",
        final_metrics
            .batches_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );

    // Cleanup
    match tokio::time::timeout(Duration::from_secs(10), cdc_service_manager.stop()).await {
        Ok(Ok(_)) => {
            println!("âœ… CDC service stopped");
        }
        Ok(Err(e)) => {
            println!("âš ï¸ Warning: Failed to stop CDC service gracefully: {:?}", e);
        }
        Err(_) => {
            println!("âš ï¸ Warning: CDC service stop timed out after 10 seconds");
        }
    }

    println!("ğŸ¯ CDC consumer test completed!");
}
