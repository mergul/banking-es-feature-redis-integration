// use banking_es::{
//     application::services::CQRSAccountService,
//     domain::{Account, AccountEvent},
//     infrastructure::{
//         cache_service::{CacheConfig, CacheService},
//         event_store::EventStore,
//         kafka_abstraction::KafkaConfig,
//         projections::ProjectionStore,
//         redis_abstraction::RealRedisClient,
//         write_batching::{WriteBatchingConfig, WriteBatchingService},
//     },
// };
// use rust_decimal::Decimal;
// use sqlx::PgPool;
// use std::sync::Arc;
// use std::time::{Duration, Instant};
// use uuid::Uuid;

// #[tokio::test]
// async fn test_batch_processing_performance() {
//     println!("üöÄ Starting Batch Processing Performance Test");

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Setup CQRS service
//     let kafka_config = KafkaConfig::default();
//     let cqrs_service = Arc::new(CQRSAccountService::new(
//         event_store.clone(),
//         projection_store.clone(),
//         cache_service.clone(),
//         kafka_config,
//         100,                    // max_connections
//         50,                     // batch_size
//         Duration::from_secs(5), // batch_timeout
//         true,                   // enable_batching
//     ));

//     // Start write batching service
//     cqrs_service
//         .start_write_batching()
//         .await
//         .expect("Failed to start write batching service");

//     println!("‚úÖ Services initialized");

//     // Performance test parameters
//     let account_count = 100;
//     let operations_per_account = 10;
//     let total_operations = account_count * operations_per_account;
//     let batch_size = 50;

//     println!("üìä Test Parameters:");
//     println!("  - Accounts: {}", account_count);
//     println!("  - Operations per account: {}", operations_per_account);
//     println!("  - Total operations: {}", total_operations);
//     println!("  - Batch size: {}", batch_size);

//     // Create test accounts
//     println!("üîÑ Creating test accounts...");
//     let start_time = Instant::now();
//     let account_ids = create_test_accounts(&cqrs_service, account_count).await;
//     let account_creation_time = start_time.elapsed();

//     println!(
//         "‚úÖ Created {} accounts in {:?}",
//         account_ids.len(),
//         account_creation_time
//     );

//     // Run batch operations test
//     println!("üîÑ Running batch operations test...");
//     let batch_start_time = Instant::now();

//     let batch_results = run_batch_operations_test(
//         &cqrs_service,
//         &account_ids,
//         operations_per_account,
//         batch_size,
//     )
//     .await;

//     let batch_duration = batch_start_time.elapsed();

//     // Run individual operations test for comparison
//     println!("üîÑ Running individual operations test...");
//     let individual_start_time = Instant::now();

//     let individual_results =
//         run_individual_operations_test(&cqrs_service, &account_ids, operations_per_account).await;

//     let individual_duration = individual_start_time.elapsed();

//     // Print results
//     println!("\nüìà PERFORMANCE RESULTS");
//     println!("=====================");
//     println!("Batch Processing:");
//     println!("  - Duration: {:?}", batch_duration);
//     println!("  - Operations: {}", batch_results.total_ops);
//     println!(
//         "  - Success Rate: {:.2}%",
//         batch_results.success_rate * 100.0
//     );
//     println!("  - Ops/sec: {:.2}", batch_results.ops_per_second);
//     println!("  - Avg Latency: {:?}", batch_results.avg_latency);

//     println!("\nIndividual Processing:");
//     println!("  - Duration: {:?}", individual_duration);
//     println!("  - Operations: {}", individual_results.total_ops);
//     println!(
//         "  - Success Rate: {:.2}%",
//         individual_results.success_rate * 100.0
//     );
//     println!("  - Ops/sec: {:.2}", individual_results.ops_per_second);
//     println!("  - Avg Latency: {:?}", individual_results.avg_latency);

//     let speedup = individual_duration.as_secs_f64() / batch_duration.as_secs_f64();
//     println!("\nüöÄ PERFORMANCE IMPROVEMENT:");
//     println!("  - Speedup: {:.2}x faster with batching", speedup);
//     println!("  - Time saved: {:?}", individual_duration - batch_duration);

//     // Verify data integrity
//     println!("\nüîç Verifying data integrity...");
//     verify_data_integrity(&cqrs_service, &account_ids).await;

//     println!("‚úÖ Batch processing performance test completed successfully!");
// }

// async fn create_test_accounts(cqrs_service: &Arc<CQRSAccountService>, count: usize) -> Vec<Uuid> {
//     let mut account_ids = Vec::new();

//     for i in 0..count {
//         let owner_name = format!("Test User {}", i);
//         let initial_balance = Decimal::new(1000, 0);

//         match cqrs_service
//             .create_account(owner_name.clone(), initial_balance)
//             .await
//         {
//             Ok(account_id) => {
//                 account_ids.push(account_id);
//             }
//             Err(e) => {
//                 println!("‚ö†Ô∏è  Failed to create account {}: {:?}", i, e);
//             }
//         }
//     }

//     account_ids
// }

// async fn run_batch_operations_test(
//     cqrs_service: &Arc<CQRSAccountService>,
//     account_ids: &[Uuid],
//     operations_per_account: usize,
//     batch_size: usize,
// ) -> TestResults {
//     let mut total_ops = 0;
//     let mut successful_ops = 0;
//     let mut total_latency = Duration::ZERO;
//     let start_time = Instant::now();

//     // Process accounts in batches
//     for batch_start in (0..account_ids.len()).step_by(batch_size) {
//         let batch_end = (batch_start + batch_size).min(account_ids.len());
//         let batch_accounts = &account_ids[batch_start..batch_end];

//         let mut batch_tasks = Vec::new();

//         for &account_id in batch_accounts {
//             for op_num in 0..operations_per_account {
//                 let cqrs_service = cqrs_service.clone();
//                 let task = tokio::spawn(async move {
//                     let op_start = Instant::now();
//                     let result = if op_num % 2 == 0 {
//                         cqrs_service
//                             .deposit_money(account_id, Decimal::new(100, 0))
//                             .await
//                     } else {
//                         cqrs_service
//                             .withdraw_money(account_id, Decimal::new(50, 0))
//                             .await
//                     };
//                     let latency = op_start.elapsed();
//                     (result.is_ok(), latency)
//                 });
//                 batch_tasks.push(task);
//             }
//         }

//         // Wait for batch to complete
//         for task in batch_tasks {
//             match task.await {
//                 Ok((success, latency)) => {
//                     total_ops += 1;
//                     if success {
//                         successful_ops += 1;
//                     }
//                     total_latency += latency;
//                 }
//                 Err(_) => {
//                     total_ops += 1;
//                 }
//             }
//         }
//     }

//     let duration = start_time.elapsed();
//     let ops_per_second = total_ops as f64 / duration.as_secs_f64();
//     let success_rate = if total_ops > 0 {
//         successful_ops as f64 / total_ops as f64
//     } else {
//         0.0
//     };
//     let avg_latency = if total_ops > 0 {
//         total_latency / total_ops as u32
//     } else {
//         Duration::ZERO
//     };

//     TestResults {
//         total_ops,
//         successful_ops,
//         success_rate,
//         ops_per_second,
//         avg_latency,
//     }
// }

// async fn run_individual_operations_test(
//     cqrs_service: &Arc<CQRSAccountService>,
//     account_ids: &[Uuid],
//     operations_per_account: usize,
// ) -> TestResults {
//     let mut total_ops = 0;
//     let mut successful_ops = 0;
//     let mut total_latency = Duration::ZERO;
//     let start_time = Instant::now();

//     for &account_id in account_ids {
//         for op_num in 0..operations_per_account {
//             let op_start = Instant::now();
//             let result = if op_num % 2 == 0 {
//                 cqrs_service
//                     .deposit_money(account_id, Decimal::new(100, 0))
//                     .await
//             } else {
//                 cqrs_service
//                     .withdraw_money(account_id, Decimal::new(50, 0))
//                     .await
//             };
//             let latency = op_start.elapsed();

//             total_ops += 1;
//             if result.is_ok() {
//                 successful_ops += 1;
//             }
//             total_latency += latency;
//         }
//     }

//     let duration = start_time.elapsed();
//     let ops_per_second = total_ops as f64 / duration.as_secs_f64();
//     let success_rate = if total_ops > 0 {
//         successful_ops as f64 / total_ops as f64
//     } else {
//         0.0
//     };
//     let avg_latency = if total_ops > 0 {
//         total_latency / total_ops as u32
//     } else {
//         Duration::ZERO
//     };

//     TestResults {
//         total_ops,
//         successful_ops,
//         success_rate,
//         ops_per_second,
//         avg_latency,
//     }
// }

// async fn verify_data_integrity(cqrs_service: &Arc<CQRSAccountService>, account_ids: &[Uuid]) {
//     let mut verified_accounts = 0;

//     for &account_id in account_ids {
//         match cqrs_service.get_account(account_id).await {
//             Ok(Some(account)) => {
//                 // Verify account exists and has reasonable balance
//                 if account.balance >= Decimal::ZERO {
//                     verified_accounts += 1;
//                 } else {
//                     println!(
//                         "‚ö†Ô∏è  Account {} has negative balance: {}",
//                         account_id, account.balance
//                     );
//                 }
//             }
//             Ok(None) => {
//                 println!("‚ö†Ô∏è  Account {} not found", account_id);
//             }
//             Err(e) => {
//                 println!("‚ö†Ô∏è  Error verifying account {}: {:?}", account_id, e);
//             }
//         }
//     }

//     println!(
//         "‚úÖ Verified {}/{} accounts have valid data",
//         verified_accounts,
//         account_ids.len()
//     );
// }

// #[derive(Debug)]
// struct TestResults {
//     total_ops: usize,
//     successful_ops: usize,
//     success_rate: f64,
//     ops_per_second: f64,
//     avg_latency: Duration,
// }

// #[tokio::test]
// async fn test_write_batching_service_performance() {
//     println!("üöÄ Starting Write Batching Service Performance Test");

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Setup write batching service
//     let write_batching_config = WriteBatchingConfig::default();
//     let write_batching_service = Arc::new(WriteBatchingService::new(
//         write_batching_config,
//         event_store.clone(),
//         projection_store.clone(),
//         Arc::new(pool.clone()),
//     ));

//     // Start write batching service
//     write_batching_service
//         .start()
//         .await
//         .expect("Failed to start write batching service");

//     println!("‚úÖ Write batching service started");

//     // Test parameters
//     let event_count = 1000;
//     let batch_size = 50;

//     println!("üìä Test Parameters:");
//     println!("  - Events: {}", event_count);
//     println!("  - Batch size: {}", batch_size);

//     // Generate test events
//     let events = generate_test_events(event_count);

//     // Test batch processing
//     println!("üîÑ Testing batch processing...");
//     let start_time = Instant::now();

//     let mut processed_events = 0;
//     for batch_start in (0..events.len()).step_by(batch_size) {
//         let batch_end = (batch_start + batch_size).min(events.len());
//         let batch_events = &events[batch_start..batch_end];

//         // Simulate batch processing
//         for event in batch_events {
//             // Add event to batch queue
//             // In real implementation, this would go through the write batching service
//             processed_events += 1;
//         }

//         // Small delay to simulate processing time
//         tokio::time::sleep(Duration::from_millis(10)).await;
//     }

//     let duration = start_time.elapsed();
//     let events_per_second = processed_events as f64 / duration.as_secs_f64();

//     println!("‚úÖ Batch processing completed:");
//     println!("  - Duration: {:?}", duration);
//     println!("  - Events processed: {}", processed_events);
//     println!("  - Events/sec: {:.2}", events_per_second);

//     // Test individual processing for comparison
//     println!("üîÑ Testing individual processing...");
//     let individual_start_time = Instant::now();

//     let mut individual_processed = 0;
//     for event in &events {
//         // Simulate individual processing
//         individual_processed += 1;

//         // Small delay to simulate processing time
//         tokio::time::sleep(Duration::from_millis(1)).await;
//     }

//     let individual_duration = individual_start_time.elapsed();
//     let individual_events_per_second =
//         individual_processed as f64 / individual_duration.as_secs_f64();

//     println!("‚úÖ Individual processing completed:");
//     println!("  - Duration: {:?}", individual_duration);
//     println!("  - Events processed: {}", individual_processed);
//     println!("  - Events/sec: {:.2}", individual_events_per_second);

//     let speedup = individual_duration.as_secs_f64() / duration.as_secs_f64();
//     println!(
//         "üöÄ Performance improvement: {:.2}x faster with batching",
//         speedup
//     );

//     println!("‚úÖ Write batching service performance test completed!");
// }

// fn generate_test_events(count: usize) -> Vec<AccountEvent> {
//     let mut events = Vec::new();

//     for i in 0..count {
//         let account_id = Uuid::new_v4();
//         let event = if i % 2 == 0 {
//             AccountEvent::AccountCreated {
//                 account_id,
//                 owner_name: format!("Test User {}", i),
//                 initial_balance: Decimal::new(1000, 0),
//             }
//         } else {
//             AccountEvent::MoneyDeposited {
//                 account_id,
//                 amount: Decimal::new(100, 0),
//                 transaction_id: Uuid::new_v4(),
//             }
//         };
//         events.push(event);
//     }

//     events
// }
