use anyhow::Result;
use banking_es::infrastructure::lock_free_operations::{
    LockFreeConfig, LockFreeOperations, LockFreeOperationsTrait,
};
use banking_es::infrastructure::redis_aggregate_lock::{
    OperationType, RedisAggregateLock, RedisLockConfig,
};
use banking_es::infrastructure::redis_lock_monitor::{
    LockAlert, RedisLockMonitor, RedisLockMonitorConfig,
};
use rust_decimal::Decimal;
use sqlx::PgPool;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::time::sleep;
use tracing::{error, info, warn};
use uuid::Uuid;

/// Performance test results
#[derive(Debug)]
struct LockPerformanceTestResult {
    test_name: String,
    total_operations: usize,
    successful_operations: usize,
    failed_operations: usize,
    total_duration: Duration,
    operations_per_second: f64,
    success_rate: f64,
    avg_latency: Duration,
    p95_latency: Duration,
    p99_latency: Duration,
    lock_metrics: serde_json::Value,
    lock_free_metrics: Option<serde_json::Value>,
}

/// Test configuration
#[derive(Debug, Clone)]
struct LockTestConfig {
    pub num_accounts: usize,
    pub num_operations: usize,
    pub concurrent_workers: usize,
    pub test_duration_secs: u64,
    pub enable_lock_free_reads: bool,
    pub enable_batch_operations: bool,
    pub enable_monitoring: bool,
}

impl Default for LockTestConfig {
    fn default() -> Self {
        Self {
            num_accounts: 100,
            num_operations: 1000,
            concurrent_workers: 10,
            test_duration_secs: 60,
            enable_lock_free_reads: true,
            enable_batch_operations: true,
            enable_monitoring: true,
        }
    }
}

/// Comprehensive Redis lock performance test
#[tokio::test]
#[ignore]
/// This test benchmarks the performance of Redis locks with various configurations,
async fn test_redis_lock_performance_improvements() -> Result<()> {
    info!("ðŸš€ Starting comprehensive Redis lock performance test");

    // Setup test environment
    let pool = PgPool::connect("postgresql://localhost/banking_test").await?;
    let event_store = Arc::new(banking_es::infrastructure::event_store::EventStore::new(
        pool.clone(),
    ));
    let projection_store =
        Arc::new(banking_es::infrastructure::projections::ProjectionStore::new(pool.clone()));

    // Test different configurations
    let configs = vec![
        (
            "Baseline (No Improvements)",
            LockTestConfig {
                enable_lock_free_reads: false,
                enable_batch_operations: false,
                enable_monitoring: false,
                ..Default::default()
            },
        ),
        (
            "With Lock-Free Reads",
            LockTestConfig {
                enable_lock_free_reads: true,
                enable_batch_operations: false,
                enable_monitoring: false,
                ..Default::default()
            },
        ),
        (
            "With Batch Operations",
            LockTestConfig {
                enable_lock_free_reads: false,
                enable_batch_operations: true,
                enable_monitoring: false,
                ..Default::default()
            },
        ),
        (
            "With Monitoring",
            LockTestConfig {
                enable_lock_free_reads: true,
                enable_batch_operations: true,
                enable_monitoring: true,
                ..Default::default()
            },
        ),
        (
            "Full Optimized",
            LockTestConfig {
                enable_lock_free_reads: true,
                enable_batch_operations: true,
                enable_monitoring: true,
                num_operations: 2000,
                concurrent_workers: 20,
                ..Default::default()
            },
        ),
    ];

    let mut results = Vec::new();

    for (test_name, config) in configs {
        info!("ðŸ§ª Running test: {}", test_name);
        let result = run_lock_performance_test(&config, &event_store, &projection_store).await?;
        results.push(result);

        // Wait between tests
        sleep(Duration::from_secs(5)).await;
    }

    // Compare and report results
    compare_performance_results(&results).await?;

    Ok(())
}

/// Run a single lock performance test
async fn run_lock_performance_test(
    config: &LockTestConfig,
    event_store: &Arc<banking_es::infrastructure::event_store::EventStore>,
    projection_store: &Arc<banking_es::infrastructure::projections::ProjectionStore>,
) -> Result<LockPerformanceTestResult> {
    let start_time = Instant::now();

    // Create Redis lock with enhanced configuration
    let redis_client = banking_es::infrastructure::redis_abstraction::RealRedisClient::new(
        redis::Client::open("redis://localhost:6379")?,
        None,
    );

    let lock_config = RedisLockConfig {
        connection_pool_size: 50,
        lock_timeout_secs: 30,
        batch_lock_timeout_secs: 60,
        retry_attempts: 3,
        retry_delay_ms: 100,
        enable_metrics: true,
        enable_lock_free_reads: config.enable_lock_free_reads,
        max_batch_size: 100,
        connection_timeout: Duration::from_secs(5),
        idle_timeout: Duration::from_secs(300),
    };

    let redis_lock = Arc::new(RedisAggregateLock::new(redis_client, lock_config));

    // Create lock-free operations service if enabled
    let lock_free_ops = if config.enable_lock_free_reads {
        let lock_free_config =
            banking_es::infrastructure::lock_free_operations::LockFreeConfig::default();
        Some(Arc::new(
            banking_es::infrastructure::lock_free_operations::LockFreeOperations::new(
                event_store.clone(),
                projection_store.clone(),
                lock_free_config,
            ),
        ))
    } else {
        None
    };

    // Create monitoring service if enabled
    let monitor = if config.enable_monitoring {
        let monitor_config = RedisLockMonitorConfig::default();
        let monitor = Arc::new(RedisLockMonitor::new(redis_lock.clone(), monitor_config));
        monitor.start().await?;
        Some(monitor)
    } else {
        None
    };

    // Create test accounts
    let account_ids = create_test_accounts(config.num_accounts, event_store).await?;
    info!("ðŸ“ Created {} test accounts", account_ids.len());

    // Run concurrent operations
    let mut latencies = Vec::new();
    let mut successful_ops = 0;
    let mut failed_ops = 0;

    let mut handles = Vec::new();

    for worker_id in 0..config.concurrent_workers {
        let redis_lock = redis_lock.clone();
        let lock_free_ops = lock_free_ops.clone();
        let account_ids = account_ids.clone();
        let operations_per_worker = config.num_operations / config.concurrent_workers;
        let enable_lock_free_reads = config.enable_lock_free_reads;

        let handle = tokio::spawn(async move {
            let mut worker_latencies = Vec::new();
            let mut worker_successful = 0;
            let mut worker_failed = 0;

            for i in 0..operations_per_worker {
                let account_id = account_ids[i % account_ids.len()];
                let operation_start = Instant::now();

                // Mix read and write operations
                let is_read_operation = i % 3 == 0; // 33% read operations

                if is_read_operation && enable_lock_free_reads {
                    // Use lock-free read operation
                    if let Some(lock_free_ops) = &lock_free_ops {
                        match lock_free_ops.get_account(account_id).await {
                            Ok(_) => {
                                worker_successful += 1;
                                worker_latencies.push(operation_start.elapsed());
                            }
                            Err(_) => {
                                worker_failed += 1;
                            }
                        }
                    }
                } else {
                    // Use traditional lock-based operation
                    let operation_type = if i % 4 == 0 {
                        OperationType::Create
                    } else {
                        OperationType::Update
                    };

                    let lock_acquired = redis_lock.try_lock(account_id, operation_type).await;
                    if lock_acquired {
                        // Simulate operation processing
                        sleep(Duration::from_millis(10)).await;
                        redis_lock.unlock(account_id).await;
                        worker_successful += 1;
                        worker_latencies.push(operation_start.elapsed());
                    } else {
                        worker_failed += 1;
                    }
                }

                // Add some delay between operations
                if i % 100 == 0 {
                    sleep(Duration::from_millis(1)).await;
                }
            }

            (worker_latencies, worker_successful, worker_failed)
        });

        handles.push(handle);
    }

    // Collect results from all workers
    for handle in handles {
        let (worker_latencies, worker_successful, worker_failed) = handle.await?;
        latencies.extend(worker_latencies);
        successful_ops += worker_successful;
        failed_ops += worker_failed;
    }

    let total_duration = start_time.elapsed();
    let total_operations = successful_ops + failed_ops;
    let operations_per_second = total_operations as f64 / total_duration.as_secs_f64();
    let success_rate = if total_operations > 0 {
        (successful_ops as f64 / total_operations as f64) * 100.0
    } else {
        0.0
    };

    // Calculate latency percentiles
    latencies.sort();
    let avg_latency = if !latencies.is_empty() {
        let total_micros: u64 = latencies.iter().map(|d| d.as_micros() as u64).sum();
        Duration::from_micros(total_micros / latencies.len() as u64)
    } else {
        Duration::ZERO
    };

    let p95_index = (latencies.len() as f64 * 0.95) as usize;
    let p99_index = (latencies.len() as f64 * 0.99) as usize;
    let p95_latency = latencies.get(p95_index).copied().unwrap_or(Duration::ZERO);
    let p99_latency = latencies.get(p99_index).copied().unwrap_or(Duration::ZERO);

    // Get lock metrics
    let lock_metrics = redis_lock.get_metrics_json();

    // Get lock-free metrics if available
    let lock_free_metrics = if let Some(lock_free_ops) = &lock_free_ops {
        Some(lock_free_ops.get_metrics_json().await)
    } else {
        None
    };

    // Stop monitoring if enabled
    if let Some(monitor) = monitor {
        monitor.stop().await?;
    }

    let result = LockPerformanceTestResult {
        test_name: format!(
            "{}",
            if config.enable_lock_free_reads {
                "Lock-Free"
            } else {
                "Traditional"
            }
        ),
        total_operations,
        successful_operations: successful_ops,
        failed_operations: failed_ops,
        total_duration,
        operations_per_second,
        success_rate,
        avg_latency,
        p95_latency,
        p99_latency,
        lock_metrics,
        lock_free_metrics,
    };

    info!(
        "âœ… Test completed: {} ops/sec, {:.2}% success rate",
        result.operations_per_second, result.success_rate
    );

    Ok(result)
}

/// Create test accounts for performance testing
async fn create_test_accounts(
    num_accounts: usize,
    event_store: &Arc<banking_es::infrastructure::event_store::EventStore>,
) -> Result<Vec<Uuid>> {
    let mut account_ids = Vec::new();

    for i in 0..num_accounts {
        let account_id = Uuid::new_v4();
        let owner_name = format!("TestUser_{}", i);
        let initial_balance = Decimal::new(1000, 0);

        // Create account event
        let account_event = banking_es::domain::AccountEvent::AccountCreated {
            account_id,
            owner_name: owner_name.clone(),
            initial_balance,
        };

        // Save to event store
        event_store
            .save_events(account_id, vec![account_event], 0)
            .await?;
        account_ids.push(account_id);
    }

    Ok(account_ids)
}

/// Compare and report performance results
async fn compare_performance_results(results: &[LockPerformanceTestResult]) -> Result<()> {
    info!("ðŸ“Š Performance Comparison Results:");
    info!("{}", "=".repeat(80));

    for result in results {
        info!("Test: {}", result.test_name);
        info!(
            "  Operations: {} ({} successful, {} failed)",
            result.total_operations, result.successful_operations, result.failed_operations
        );
        info!("  Throughput: {:.2} ops/sec", result.operations_per_second);
        info!("  Success Rate: {:.2}%", result.success_rate);
        info!(
            "  Latency - Avg: {:?}, P95: {:?}, P99: {:?}",
            result.avg_latency, result.p95_latency, result.p99_latency
        );

        // Display lock metrics
        if let Some(lock_metrics) = result.lock_metrics.as_object() {
            if let Some(success_rate) = lock_metrics.get("success_rate") {
                info!(
                    "  Lock Success Rate: {:.2}%",
                    success_rate.as_f64().unwrap_or(0.0)
                );
            }
            if let Some(avg_time) = lock_metrics.get("avg_lock_acquisition_time_us") {
                info!("  Avg Lock Time: {}Î¼s", avg_time.as_u64().unwrap_or(0));
            }
        }

        // Display lock-free metrics if available
        if let Some(lock_free_metrics) = &result.lock_free_metrics {
            if let Some(lock_free_metrics) = lock_free_metrics.as_object() {
                if let Some(cache_hit_rate) = lock_free_metrics.get("cache_hit_rate") {
                    info!(
                        "  Cache Hit Rate: {:.2}%",
                        cache_hit_rate.as_f64().unwrap_or(0.0)
                    );
                }
                if let Some(avg_read_time) = lock_free_metrics.get("avg_read_time_us") {
                    info!("  Avg Read Time: {}Î¼s", avg_read_time.as_u64().unwrap_or(0));
                }
            }
        }

        info!("");
    }

    // Find best performing configuration
    if let Some(best_result) = results.iter().max_by(|a, b| {
        a.operations_per_second
            .partial_cmp(&b.operations_per_second)
            .unwrap()
    }) {
        info!(
            "ðŸ† Best Performance: {} with {:.2} ops/sec",
            best_result.test_name, best_result.operations_per_second
        );
    }

    Ok(())
}

/// Test batch lock acquisition performance
#[tokio::test]
#[ignore]
async fn test_batch_lock_performance() -> Result<()> {
    info!("ðŸ§ª Testing batch lock acquisition performance");

    let redis_client = banking_es::infrastructure::redis_abstraction::RealRedisClient::new(
        redis::Client::open("redis://localhost:6379")?,
        None,
    );

    let lock_config = RedisLockConfig::default();
    let redis_lock = Arc::new(RedisAggregateLock::new(redis_client, lock_config));

    let batch_sizes = vec![1, 10, 50, 100, 200];
    let num_batches = 100;

    for batch_size in batch_sizes {
        let start_time = Instant::now();
        let mut successful_locks = 0;
        let mut total_locks = 0;

        for _ in 0..num_batches {
            let aggregate_ids: Vec<Uuid> = (0..batch_size).map(|_| Uuid::new_v4()).collect();
            let operation_types: Vec<OperationType> =
                (0..batch_size).map(|_| OperationType::Update).collect();

            let lock_results = redis_lock
                .try_batch_lock(aggregate_ids.clone(), operation_types)
                .await;

            let batch_successful = lock_results.iter().filter(|&&r| r).count();
            successful_locks += batch_successful;
            total_locks += batch_size;

            // Release locks
            let acquired_ids: Vec<Uuid> = aggregate_ids
                .iter()
                .zip(lock_results.iter())
                .filter(|(_, &acquired)| acquired)
                .map(|(id, _)| *id)
                .collect();

            if !acquired_ids.is_empty() {
                redis_lock.batch_unlock(acquired_ids).await;
            }
        }

        let duration = start_time.elapsed();
        let success_rate = (successful_locks as f64 / total_locks as f64) * 100.0;
        let locks_per_second = total_locks as f64 / duration.as_secs_f64();

        info!(
            "Batch Size {}: {:.2} locks/sec, {:.2}% success rate",
            batch_size, locks_per_second, success_rate
        );
    }

    Ok(())
}

/// Test lock-free operations performance
#[tokio::test]
#[ignore]
async fn test_lock_free_operations_performance() -> Result<()> {
    info!("ðŸ§ª Testing lock-free operations performance");

    let pool = PgPool::connect("postgresql://localhost/banking_test").await?;
    let event_store = Arc::new(banking_es::infrastructure::event_store::EventStore::new(
        pool.clone(),
    ));
    let projection_store =
        Arc::new(banking_es::infrastructure::projections::ProjectionStore::new(pool));

    let lock_free_config =
        banking_es::infrastructure::lock_free_operations::LockFreeConfig::default();
    let lock_free_ops = Arc::new(
        banking_es::infrastructure::lock_free_operations::LockFreeOperations::new(
            event_store.clone(),
            projection_store,
            lock_free_config,
        ),
    );

    // Create test accounts
    let account_ids = create_test_accounts(100, &event_store).await?;

    let num_operations = 1000;
    let start_time = Instant::now();
    let mut successful_ops = 0;

    for i in 0..num_operations {
        let account_id = account_ids[i % account_ids.len()];

        match lock_free_ops.get_account(account_id).await {
            Ok(_) => successful_ops += 1,
            Err(_) => {}
        }

        if i % 100 == 0 {
            sleep(Duration::from_millis(1)).await;
        }
    }

    let duration = start_time.elapsed();
    let operations_per_second = successful_ops as f64 / duration.as_secs_f64();
    let success_rate = (successful_ops as f64 / num_operations as f64) * 100.0;

    info!(
        "Lock-Free Operations: {:.2} ops/sec, {:.2}% success rate",
        operations_per_second, success_rate
    );

    // Get metrics
    let metrics = lock_free_ops.get_metrics_json().await;
    info!("Lock-Free Metrics: {:?}", metrics);

    Ok(())
}

/// Test monitoring and alerting
#[tokio::test]
#[ignore]
async fn test_monitoring_and_alerting() -> Result<()> {
    info!("ðŸ§ª Testing monitoring and alerting");

    let redis_client = banking_es::infrastructure::redis_abstraction::RealRedisClient::new(
        redis::Client::open("redis://localhost:6379")?,
        None,
    );

    let lock_config = RedisLockConfig::default();
    let redis_lock = Arc::new(RedisAggregateLock::new(redis_client, lock_config));

    let monitor_config = RedisLockMonitorConfig {
        monitoring_interval_secs: 5,          // Faster monitoring for testing
        alert_threshold_success_rate: 99.0,   // Very high threshold to trigger alerts
        alert_threshold_avg_lock_time_ms: 10, // Very low threshold to trigger alerts
        alert_threshold_contention_rate: 1.0, // Very low threshold to trigger alerts
        alert_threshold_timeout_rate: 1.0,    // Very low threshold to trigger alerts
        enable_alerts: true,
        enable_metrics_logging: true,
        enable_performance_tracking: true,
    };

    let monitor = Arc::new(RedisLockMonitor::new(redis_lock.clone(), monitor_config));
    monitor.start().await?;

    // Generate some load to trigger monitoring
    let account_ids: Vec<Uuid> = (0..50).map(|_| Uuid::new_v4()).collect();

    for _ in 0..100 {
        for &account_id in &account_ids {
            let _ = redis_lock.try_lock(account_id, OperationType::Update).await;
            // Don't release locks immediately to create contention
        }
        sleep(Duration::from_millis(10)).await;
    }

    // Wait for monitoring to collect data
    sleep(Duration::from_secs(10)).await;

    // Get monitoring report
    let report = monitor.get_monitoring_report().await;
    info!("Monitoring Report: {:?}", report);

    // Check for alerts
    let alert_history = monitor.get_alert_history().await;
    info!("Alert History: {} alerts", alert_history.len());

    for alert in alert_history {
        match alert {
            LockAlert::LowSuccessRate { current, threshold } => {
                warn!(
                    "Alert: Low success rate - {}% (threshold: {}%)",
                    current, threshold
                );
            }
            LockAlert::HighLockTime {
                current_ms,
                threshold_ms,
            } => {
                warn!(
                    "Alert: High lock time - {}ms (threshold: {}ms)",
                    current_ms, threshold_ms
                );
            }
            LockAlert::HighContentionRate { current, threshold } => {
                warn!(
                    "Alert: High contention rate - {}% (threshold: {}%)",
                    current, threshold
                );
            }
            LockAlert::HighTimeoutRate { current, threshold } => {
                warn!(
                    "Alert: High timeout rate - {}% (threshold: {}%)",
                    current, threshold
                );
            }
            LockAlert::ConnectionPoolExhaustion { hit_rate } => {
                warn!(
                    "Alert: Connection pool exhaustion - hit rate: {}%",
                    hit_rate
                );
            }
            LockAlert::LockServiceUnhealthy { error } => {
                error!("Alert: Lock service unhealthy - {}", error);
            }
        }
    }

    monitor.stop().await?;

    Ok(())
}
