use banking_es::{
    application::services::CQRSAccountService,
    infrastructure::{
        cdc_debezium::{CDCOutboxRepository, DebeziumConfig},
        cdc_service_manager::{CDCServiceManager, EnhancedCDCMetrics},
        init,
    },
};
use rust_decimal::Decimal;
use std::sync::Arc;
use std::time::{Duration, Instant};
use uuid::Uuid;

#[tokio::test]
async fn test_enhanced_stress_with_reads() {
    println!("ğŸš€ Enhanced Stress Test with Read Operations");
    println!("=============================================");

    // Initialize services
    let service_context = match banking_es::infrastructure::init::init_all_services().await {
        Ok(ctx) => {
            println!("âœ… Services initialized");
            ctx
        }
        Err(e) => {
            println!("âŒ Service initialization failed: {:?}", e);
            return;
        }
    };

    // Create CQRS service with optimized settings
    let kafka_config = banking_es::infrastructure::kafka_abstraction::KafkaConfig::default();
    let cqrs_service = Arc::new(CQRSAccountService::new(
        service_context.event_store.clone(),
        service_context.projection_store.clone(),
        service_context.cache_service.clone(),
        kafka_config.clone(),
        15, // Increased concurrency
        20, // Larger batch size
        Duration::from_millis(100),
        true, // Enable write batching
    ));

    // Start write batching service
    cqrs_service
        .start_write_batching()
        .await
        .expect("Failed to start write batching");
    println!("âœ… Write batching service started");

    // Create and start CDC service manager
    println!("ğŸ”§ Setting up CDC service manager...");
    let cdc_outbox_repo = Arc::new(CDCOutboxRepository::new(
        service_context.event_store.get_partitioned_pools().clone(),
    ));

    let kafka_producer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaProducer::new(kafka_config.clone())
            .expect("Failed to create Kafka producer");
    let kafka_consumer_for_cdc =
        banking_es::infrastructure::kafka_abstraction::KafkaConsumer::new(kafka_config.clone())
            .expect("Failed to create Kafka consumer");

    let cdc_config = DebeziumConfig::default();
    let metrics = Arc::new(EnhancedCDCMetrics::default());

    let mut cdc_service_manager = CDCServiceManager::new(
        cdc_config,
        cdc_outbox_repo,
        kafka_producer_for_cdc,
        kafka_consumer_for_cdc,
        service_context.cache_service.clone(),
        service_context.projection_store.clone(),
        Some(metrics.clone()),
        Some(cqrs_service.get_consistency_manager()),
    )
    .expect("Failed to create CDC service manager");

    // Start CDC service with timeout
    println!("ğŸ”§ Starting CDC service manager...");
    match tokio::time::timeout(Duration::from_secs(30), cdc_service_manager.start()).await {
        Ok(Ok(_)) => {
            println!("âœ… CDC Service Manager started");
        }
        Ok(Err(e)) => {
            println!("âŒ Failed to start CDC service: {:?}", e);
            return;
        }
        Err(_) => {
            println!("âŒ CDC service manager start timed out after 30 seconds");
            return;
        }
    }

    // Get the processor with batch processing enabled
    let processor = match tokio::time::timeout(
        Duration::from_secs(10),
        cdc_service_manager.get_processor_with_batch_enabled(),
    )
    .await
    {
        Ok(Ok(proc)) => {
            println!("âœ… CDC Event Processor with batch processing enabled retrieved");
            proc
        }
        Ok(Err(e)) => {
            println!("âŒ Failed to get CDC processor: {:?}", e);
            return;
        }
        Err(_) => {
            println!("âŒ CDC processor retrieval timed out after 10 seconds");
            return;
        }
    };

    // Verify batch processing is enabled
    let is_batch_running = match tokio::time::timeout(
        Duration::from_secs(5),
        processor.is_batch_processor_running(),
    )
    .await
    {
        Ok(running) => {
            println!("âœ… CDC Batch Processor running: {}", running);
            running
        }
        Err(_) => {
            println!("âŒ Batch processor status check timed out");
            return;
        }
    };

    println!("âœ… CQRS service created with enhanced settings");

    // Test parameters - Increased for higher concurrency
    let num_accounts = 100;
    let num_workers = 15; // Increased from 10 to 15 workers
    let operations_per_worker = 30; // Increased from 20 to 30 operations
    let total_operations = num_workers * operations_per_worker;

    println!("ğŸ“Š Test Configuration:");
    println!("   Accounts to create: {}", num_accounts);
    println!("   Workers: {}", num_workers);
    println!("   Operations per worker: {}", operations_per_worker);
    println!("   Total operations: {}", total_operations);

    // Phase 1: Create accounts
    println!("\nğŸ“ Phase 1: Creating {} accounts", num_accounts);
    let create_start = Instant::now();
    let mut account_ids = Vec::new();

    for i in 0..num_accounts {
        match cqrs_service
            .create_account(format!("StressUser{}", i), Decimal::new(1000, 0))
            .await
        {
            Ok(account_id) => {
                account_ids.push(account_id);
                if (i + 1) % 10 == 0 {
                    println!("  âœ… Created {} accounts", i + 1);
                }
            }
            Err(e) => {
                println!("  âŒ Failed to create account {}: {:?}", i + 1, e);
            }
        }
    }

    let create_time = create_start.elapsed();
    println!("âœ… Account creation completed in {:?}", create_time);
    println!(
        "   Successfully created: {}/{} accounts",
        account_ids.len(),
        num_accounts
    );

    // Wait for projections to catch up with longer delay
    println!("â³ Waiting for projections to update...");
    tokio::time::sleep(Duration::from_secs(10)).await; // Increased from 5s to 10s

    // Phase 2: Mixed read/write operations
    println!("\nğŸ”„ Phase 2: Mixed Read/Write Operations");
    let mixed_start = Instant::now();

    let mut handles = Vec::new();
    let mut success_count = 0u32;
    let mut error_count = 0u32;
    let success_counter = Arc::new(std::sync::atomic::AtomicU32::new(0));
    let error_counter = Arc::new(std::sync::atomic::AtomicU32::new(0));

    for worker_id in 0..num_workers {
        let service = cqrs_service.clone();
        let accounts = account_ids.clone();
        let success_counter = success_counter.clone();
        let error_counter = error_counter.clone();

        let handle = tokio::spawn(async move {
            let mut worker_success = 0;
            let mut worker_errors = 0;

            for op_id in 0..operations_per_worker {
                let account_id = accounts[op_id % accounts.len()];
                let operation_type = op_id % 5; // 0=read, 1=deposit, 2=withdraw, 3=read, 4=balance

                match operation_type {
                    0 | 3 => {
                        // Read operation
                        match service.get_account(account_id).await {
                            Ok(Some(account)) => {
                                worker_success += 1;
                                if op_id % 10 == 0 {
                                    println!(
                                        "  Worker {}: Read account {} (balance: {})",
                                        worker_id, account_id, account.balance
                                    );
                                }
                            }
                            Ok(None) => {
                                worker_errors += 1;
                                if op_id % 5 == 0 {
                                    println!(
                                        "  Worker {}: Account {} not found",
                                        worker_id, account_id
                                    );
                                }
                            }
                            Err(e) => {
                                worker_errors += 1;
                                if op_id % 5 == 0 {
                                    println!("  Worker {}: Read error: {:?}", worker_id, e);
                                }
                            }
                        }
                    }
                    4 => {
                        // Balance check operation
                        match service.get_account_balance(account_id).await {
                            Ok(balance) => {
                                worker_success += 1;
                                if op_id % 10 == 0 {
                                    println!(
                                        "  Worker {}: Balance check for account {}: {}",
                                        worker_id, account_id, balance
                                    );
                                }
                            }
                            Err(e) => {
                                worker_errors += 1;
                                if op_id % 5 == 0 {
                                    println!("  Worker {}: Balance error: {:?}", worker_id, e);
                                }
                            }
                        }
                    }
                    1 => {
                        // Deposit operation
                        match service
                            .deposit_money(account_id, Decimal::new(100, 0))
                            .await
                        {
                            Ok(_) => {
                                worker_success += 1;
                                if op_id % 10 == 0 {
                                    println!(
                                        "  Worker {}: Deposited 100 to account {}",
                                        worker_id, account_id
                                    );
                                }
                            }
                            Err(e) => {
                                worker_errors += 1;
                                if op_id % 5 == 0 {
                                    println!("  Worker {}: Deposit error: {:?}", worker_id, e);
                                }
                            }
                        }
                    }
                    2 => {
                        // Withdraw operation
                        match service
                            .withdraw_money(account_id, Decimal::new(50, 0))
                            .await
                        {
                            Ok(_) => {
                                worker_success += 1;
                                if op_id % 10 == 0 {
                                    println!(
                                        "  Worker {}: Withdrew 50 from account {}",
                                        worker_id, account_id
                                    );
                                }
                            }
                            Err(e) => {
                                worker_errors += 1;
                                if op_id % 5 == 0 {
                                    println!("  Worker {}: Withdraw error: {:?}", worker_id, e);
                                }
                            }
                        }
                    }
                    _ => unreachable!(),
                }

                // Small delay between operations to prevent overwhelming
                if op_id % 5 == 0 {
                    tokio::time::sleep(Duration::from_millis(10)).await;
                }
            }

            success_counter.fetch_add(worker_success, std::sync::atomic::Ordering::Relaxed);
            error_counter.fetch_add(worker_errors, std::sync::atomic::Ordering::Relaxed);

            (worker_success, worker_errors)
        });

        handles.push(handle);
    }

    // Wait for all workers to complete
    let mut worker_results = Vec::new();
    for handle in handles {
        match handle.await {
            Ok(result) => worker_results.push(result),
            Err(e) => {
                println!("âŒ Worker panicked: {:?}", e);
                error_counter.fetch_add(
                    operations_per_worker as u32,
                    std::sync::atomic::Ordering::Relaxed,
                );
            }
        }
    }

    let mixed_time = mixed_start.elapsed();
    let total_success = success_counter.load(std::sync::atomic::Ordering::Relaxed);
    let total_errors = error_counter.load(std::sync::atomic::Ordering::Relaxed);

    println!("âœ… Mixed operations completed in {:?}", mixed_time);
    println!(
        "   Successful operations: {}/{} ({:.1}%)",
        total_success,
        total_operations,
        (total_success as f64 / total_operations as f64) * 100.0
    );
    println!(
        "   Failed operations: {}/{} ({:.1}%)",
        total_errors,
        total_operations,
        (total_errors as f64 / total_operations as f64) * 100.0
    );

    // Phase 3: Final verification
    println!("\nğŸ” Phase 3: Final Verification");
    let verify_start = Instant::now();
    let mut verified_accounts = 0;

    for account_id in &account_ids {
        match cqrs_service.get_account(*account_id).await {
            Ok(Some(account)) => {
                verified_accounts += 1;
                if verified_accounts % 10 == 0 {
                    println!(
                        "  âœ… Verified account {} (balance: {}, active: {})",
                        account_id, account.balance, account.is_active
                    );
                }
            }
            Ok(None) => {
                println!("  âš ï¸ Account {} not found in projections", account_id);
            }
            Err(e) => {
                println!("  âŒ Error verifying account {}: {:?}", account_id, e);
            }
        }
    }

    let verify_time = verify_start.elapsed();
    println!("âœ… Verification completed in {:?}", verify_time);
    println!(
        "   Verified accounts: {}/{}",
        verified_accounts,
        account_ids.len()
    );

    // Performance metrics
    let total_time = create_start.elapsed();
    let throughput = total_operations as f64 / total_time.as_secs_f64();
    let avg_latency = total_time.as_millis() as f64 / total_operations as f64;

    println!("\nğŸ“ˆ Performance Summary:");
    println!("   Total test time: {:?}", total_time);
    println!("   Throughput: {:.1} ops/sec", throughput);
    println!("   Average latency: {:.1} ms/op", avg_latency);
    println!(
        "   Success rate: {:.1}%",
        (total_success as f64 / total_operations as f64) * 100.0
    );

    // Get service metrics
    let metrics = cqrs_service.get_metrics();
    println!("\nğŸ“Š Service Metrics:");
    println!(
        "   Commands processed: {}",
        metrics
            .commands_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Commands successful: {}",
        metrics
            .commands_successful
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Commands failed: {}",
        metrics
            .commands_failed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Queries processed: {}",
        metrics
            .queries_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Queries successful: {}",
        metrics
            .queries_successful
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Queries failed: {}",
        metrics
            .queries_failed
            .load(std::sync::atomic::Ordering::Relaxed)
    );

    // Get CDC metrics
    let cdc_metrics = cdc_service_manager.get_metrics();
    println!("\nğŸ“Š CDC Pipeline Metrics:");
    println!(
        "   Events Processed: {}",
        cdc_metrics
            .events_processed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Events Failed: {}",
        cdc_metrics
            .events_failed
            .load(std::sync::atomic::Ordering::Relaxed)
    );
    println!(
        "   Projection Updates: {}",
        cdc_metrics
            .projection_updates
            .load(std::sync::atomic::Ordering::Relaxed)
    );

    // Cleanup with timeout
    match tokio::time::timeout(Duration::from_secs(10), cdc_service_manager.stop()).await {
        Ok(Ok(_)) => {
            println!("âœ… CDC service stopped");
        }
        Ok(Err(e)) => {
            println!("âš ï¸ Warning: Failed to stop CDC service gracefully: {:?}", e);
        }
        Err(_) => {
            println!("âš ï¸ Warning: CDC service stop timed out after 10 seconds");
        }
    }

    println!("ğŸ¯ Enhanced stress test completed!");
}
