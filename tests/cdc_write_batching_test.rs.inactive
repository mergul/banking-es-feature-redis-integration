// use banking_es::{
//     application::services::CQRSAccountService,
//     infrastructure::{
//         cache_service::{CacheConfig, CacheService},
//         connection_pool_partitioning::{OperationType, PoolSelector},
//         event_store::{EventStore, EventStoreTrait},
//         kafka_abstraction::KafkaConfig,
//         outbox::{OutboxMessage, OutboxRepositoryTrait},
//         projections::ProjectionStore,
//         redis_abstraction::RealRedisClient,
//         write_batching::{WriteBatchingConfig, WriteBatchingService},
//     },
// };
// use rust_decimal::Decimal;
// use sqlx::PgPool;
// use std::sync::Arc;
// use std::time::{Duration, Instant};
// use uuid::Uuid;

// #[tokio::test]
// async fn test_write_batching_cdc_integration() {
//     println!("ğŸš€ Testing Write Batching CDC Integration (Fixed Performance)");

//     let test_start = Instant::now();

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Create CDC outbox table
//     let cdc_repo = banking_es::infrastructure::cdc_debezium::CDCOutboxRepository::new(
//         event_store.get_partitioned_pools().clone(),
//     );
//     cdc_repo
//         .create_cdc_outbox_table()
//         .await
//         .expect("Failed to create CDC outbox table");

//     // Setup CQRS service with OPTIMIZED write batching configuration
//     let kafka_config = KafkaConfig::default();
//     let cqrs_service = Arc::new(CQRSAccountService::new(
//         event_store.clone(),
//         projection_store.clone(),
//         cache_service.clone(),
//         kafka_config,
//         50,
//         25,
//         Duration::from_secs(2),
//         true, // ENABLE write batching with FIXED implementation
//     ));

//     // Start write batching service
//     cqrs_service
//         .start_write_batching()
//         .await
//         .expect("Failed to start write batching service");

//     println!("âœ… Services initialized with OPTIMIZED write batching enabled");

//     // Test 1: Create one account using FIXED write batching
//     println!("ğŸ“ Creating test account using FIXED write batching...");
//     let account_start = Instant::now();

//     let owner_name = "CDCTestUser_Fixed".to_string();
//     let initial_balance = Decimal::new(1000, 0);

//     let account_id = match cqrs_service
//         .create_account(owner_name.clone(), initial_balance)
//         .await
//     {
//         Ok(account_id) => {
//             let account_duration = account_start.elapsed();
//             println!(
//                 "âœ… Created account {} for user {} in {:?}",
//                 account_id, owner_name, account_duration
//             );
//             account_id
//         }
//         Err(e) => {
//             println!("âŒ Failed to create account: {:?}", e);
//             panic!("Account creation failed");
//         }
//     };

//     // Test 2: Check consistency manager status immediately
//     println!("ğŸ”§ Checking consistency manager status...");
//     let consistency_manager = cqrs_service.get_consistency_manager();

//     let status = consistency_manager.get_status(account_id).await;
//     println!("ğŸ“Š CDC status for account {}: {:?}", account_id, status);

//     // Test 3: Perform one operation on account
//     println!("ğŸ’° Performing operation on account...");
//     let deposit_start = Instant::now();

//     match cqrs_service
//         .deposit_money(account_id, Decimal::new(100, 0))
//         .await
//     {
//         Ok(_) => {
//             let deposit_duration = deposit_start.elapsed();
//             println!(
//                 "âœ… Deposited 100 to account {} in {:?}",
//                 account_id, deposit_duration
//             );
//         }
//         Err(e) => println!("âŒ Failed to deposit to account {}: {:?}", account_id, e),
//     }

//     // Test 4: Check consistency manager stats
//     println!("ğŸ“Š Consistency manager stats...");
//     let final_stats = consistency_manager.get_stats().await;
//     println!(
//         "ğŸ“Š Consistency manager stats: {}",
//         serde_json::to_string_pretty(&final_stats).unwrap()
//     );

//     let total_tracked = final_stats["total_tracked"].as_u64().unwrap_or(0);
//     let pending = final_stats["pending"].as_u64().unwrap_or(0);

//     println!("ğŸ“Š Summary:");
//     println!("  - Total operations tracked: {}", total_tracked);
//     println!("  - Operations pending: {}", pending);

//     assert!(
//         total_tracked > 0,
//         "Consistency manager should track operations"
//     );

//     // Test 5: Test CQRS service health
//     println!("ğŸ”§ Testing CQRS service health...");
//     match cqrs_service.health_check().await {
//         Ok(health) => {
//             println!("ğŸ“Š CQRS service health: {:?}", health);
//             assert_eq!(health.status, "healthy", "CQRS service should be healthy");
//         }
//         Err(e) => {
//             println!("âš ï¸ Health check failed: {:?}", e);
//             panic!("Health check failed");
//         }
//     }

//     // Test 6: Test consistency manager methods directly
//     println!("ğŸ”§ Testing consistency manager methods...");

//     // Test marking as completed (simulating CDC processing)
//     consistency_manager.mark_completed(account_id).await;
//     let completed_status = consistency_manager.get_status(account_id).await;
//     println!("ğŸ“Š Status after marking completed: {:?}", completed_status);

//     // Test marking as failed
//     consistency_manager
//         .mark_failed(account_id, "Test failure".to_string())
//         .await;
//     let failed_status = consistency_manager.get_status(account_id).await;
//     println!("ğŸ“Š Status after marking failed: {:?}", failed_status);

//     let total_duration = test_start.elapsed();
//     println!(
//         "âœ… CDC Write Batching Integration Test completed in {:?}!",
//         total_duration
//     );

//     // Performance assertion
//     assert!(
//         total_duration < Duration::from_secs(10),
//         "Test should complete in under 10 seconds, but took {:?}",
//         total_duration
//     );
// }

// #[tokio::test]
// async fn test_minimal_performance_baseline() {
//     println!("ğŸš€ Testing Minimal Performance Baseline (No Write Batching)");

//     let test_start = Instant::now();

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Setup CQRS service WITHOUT write batching (baseline)
//     let kafka_config = KafkaConfig::default();
//     let cqrs_service = Arc::new(CQRSAccountService::new(
//         event_store.clone(),
//         projection_store.clone(),
//         cache_service.clone(),
//         kafka_config,
//         50,
//         25,
//         Duration::from_secs(2),
//         false, // DISABLE write batching for baseline
//     ));

//     println!("âœ… Services initialized WITHOUT write batching (baseline)");

//     // Test 1: Create one account using direct handler
//     println!("ğŸ“ Creating test account using direct handler...");
//     let account_start = Instant::now();

//     let owner_name = "CDCTestUser_Baseline".to_string();
//     let initial_balance = Decimal::new(1000, 0);

//     let account_id = match cqrs_service
//         .create_account(owner_name.clone(), initial_balance)
//         .await
//     {
//         Ok(account_id) => {
//             let account_duration = account_start.elapsed();
//             println!(
//                 "âœ… Created account {} for user {} in {:?}",
//                 account_id, owner_name, account_duration
//             );
//             account_id
//         }
//         Err(e) => {
//             println!("âŒ Failed to create account: {:?}", e);
//             panic!("Account creation failed");
//         }
//     };

//     // Test 2: Perform one operation on account
//     println!("ğŸ’° Performing operation on account...");
//     let deposit_start = Instant::now();

//     match cqrs_service
//         .deposit_money(account_id, Decimal::new(100, 0))
//         .await
//     {
//         Ok(_) => {
//             let deposit_duration = deposit_start.elapsed();
//             println!(
//                 "âœ… Deposited 100 to account {} in {:?}",
//                 account_id, deposit_duration
//             );
//         }
//         Err(e) => println!("âŒ Failed to deposit to account {}: {:?}", account_id, e),
//     }

//     let total_duration = test_start.elapsed();
//     println!(
//         "âœ… Minimal Performance Baseline Test completed in {:?}!",
//         total_duration
//     );

//     // Performance assertion - should be much faster
//     assert!(
//         total_duration < Duration::from_secs(2),
//         "Baseline test should complete in under 2 seconds, but took {:?}",
//         total_duration
//     );
// }

// #[tokio::test]
// async fn test_outbox_processing_performance() {
//     println!("ğŸš€ Testing Outbox Processing Performance");

//     let test_start = Instant::now();

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Create CDC outbox table
//     let partitioned_pools = event_store.get_partitioned_pools();
//     let cdc_repo = banking_es::infrastructure::cdc_debezium::CDCOutboxRepository::new(
//         partitioned_pools.clone(),
//     );
//     cdc_repo
//         .create_cdc_outbox_table()
//         .await
//         .expect("Failed to create CDC outbox table");

//     // Test direct outbox batcher performance
//     println!("ğŸ“Š Testing direct outbox batcher performance...");

//     let outbox_repo = Arc::new(cdc_repo.clone()) as Arc<dyn OutboxRepositoryTrait>;
//     let outbox_batcher = banking_es::infrastructure::cdc_debezium::OutboxBatcher::new_default(
//         outbox_repo,
//         event_store.get_partitioned_pools().clone(),
//     );

//     // Test 1: Single message submission
//     println!("ğŸ“ Testing single message submission...");
//     let single_start = Instant::now();

//     let outbox_message = OutboxMessage {
//         aggregate_id: Uuid::new_v4(),
//         event_id: Uuid::new_v4(),
//         event_type: "TestEvent".to_string(),
//         payload: b"test payload".to_vec(),
//         topic: "test-topic".to_string(),
//         metadata: None,
//     };

//     outbox_batcher
//         .submit(outbox_message)
//         .await
//         .expect("Failed to submit message");

//     // OPTIMIZED: Reduced wait time from 100ms to 20ms
//     tokio::time::sleep(Duration::from_millis(20)).await;

//     let single_duration = single_start.elapsed();
//     println!("âœ… Single message processed in {:?}", single_duration);

//     // Test 2: Multiple messages submission
//     println!("ğŸ“ Testing multiple messages submission...");
//     let multiple_start = Instant::now();

//     for i in 0..5 {
//         let outbox_message = OutboxMessage {
//             aggregate_id: Uuid::new_v4(),
//             event_id: Uuid::new_v4(),
//             event_type: format!("TestEvent{}", i),
//             payload: b"test payload".to_vec(),
//             topic: "test-topic".to_string(),
//             metadata: None,
//         };

//         outbox_batcher
//             .submit(outbox_message)
//             .await
//             .expect("Failed to submit message");
//     }

//     // OPTIMIZED: Reduced wait time from 200ms to 50ms
//     tokio::time::sleep(Duration::from_millis(50)).await;

//     let multiple_duration = multiple_start.elapsed();
//     println!("âœ… Multiple messages processed in {:?}", multiple_duration);

//     // Test 3: Database insertion performance
//     println!("ğŸ“Š Testing direct database insertion performance...");
//     let db_start = Instant::now();

//     let partitioned_pools = event_store.get_partitioned_pools();
//     let write_pool = partitioned_pools.select_pool(OperationType::Write);
//     let mut transaction = write_pool
//         .begin()
//         .await
//         .expect("Failed to begin transaction");

//     let test_messages = vec![OutboxMessage {
//         aggregate_id: Uuid::new_v4(),
//         event_id: Uuid::new_v4(),
//         event_type: "DirectTest".to_string(),
//         payload: b"test payload".to_vec(),
//         topic: "test-topic".to_string(),
//         metadata: None,
//     }];

//     cdc_repo
//         .add_pending_messages(&mut transaction, test_messages)
//         .await
//         .expect("Failed to add messages");
//     transaction
//         .commit()
//         .await
//         .expect("Failed to commit transaction");

//     let db_duration = db_start.elapsed();
//     println!("âœ… Direct database insertion in {:?}", db_duration);

//     let total_duration = test_start.elapsed();
//     println!(
//         "âœ… Outbox Processing Performance Test completed in {:?}!",
//         total_duration
//     );

//     // Performance assertions
//     assert!(
//         single_duration < Duration::from_secs(1),
//         "Single message should be processed in under 1 second, but took {:?}",
//         single_duration
//     );

//     assert!(
//         multiple_duration < Duration::from_secs(2),
//         "Multiple messages should be processed in under 2 seconds, but took {:?}",
//         multiple_duration
//     );

//     assert!(
//         db_duration < Duration::from_millis(100),
//         "Direct database insertion should be under 100ms, but took {:?}",
//         db_duration
//     );
// }

// #[tokio::test]
// async fn test_all_write_operations_performance() {
//     println!("ğŸš€ Testing All Write Operations Performance (Optimized)");

//     // Setup database connection
//     let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
//         "postgresql://postgres:Francisco1@localhost:5432/banking_es".to_string()
//     });

//     let pool = PgPool::connect(&database_url)
//         .await
//         .expect("Failed to connect to database");

//     // Setup Redis client
//     let redis_url =
//         std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://localhost:6379".to_string());
//     let redis_client = redis::Client::open(redis_url).expect("Failed to create Redis client");
//     let redis_client_trait = RealRedisClient::new(redis_client, None);

//     // Setup services
//     let event_store = Arc::new(EventStore::new(pool.clone()));
//     let cache_config = CacheConfig::default();
//     let cache_service = Arc::new(CacheService::new(redis_client_trait, cache_config));
//     let projection_store = Arc::new(ProjectionStore::new(pool.clone()));

//     // Create CDC outbox table
//     let cdc_repo = banking_es::infrastructure::cdc_debezium::CDCOutboxRepository::new(
//         event_store.get_partitioned_pools().clone(),
//     );
//     cdc_repo
//         .create_cdc_outbox_table()
//         .await
//         .expect("Failed to create CDC outbox table");

//     // Setup CQRS service with OPTIMIZED write batching configuration
//     let kafka_config = KafkaConfig::default();
//     let cqrs_service = Arc::new(CQRSAccountService::new(
//         event_store.clone(),
//         projection_store.clone(),
//         cache_service.clone(),
//         kafka_config,
//         50,
//         25,
//         Duration::from_secs(2),
//         true, // ENABLE write batching with OPTIMIZED implementation
//     ));

//     // Start write batching service
//     cqrs_service
//         .start_write_batching()
//         .await
//         .expect("Failed to start write batching service");

//     println!("âœ… Services initialized with OPTIMIZED write batching enabled");

//     // Test 1: Create Account Performance
//     println!("ğŸ“ Testing account creation performance...");
//     let start_time = std::time::Instant::now();
//     let account_id = cqrs_service
//         .create_account("PerformanceTest_User".to_string(), Decimal::new(1000, 0))
//         .await
//         .expect("Failed to create account");
//     let create_duration = start_time.elapsed();
//     println!("âœ… Created account {} in {:?}", account_id, create_duration);

//     // Test 2: Deposit Performance
//     println!("ğŸ’° Testing deposit performance...");
//     let start_time = std::time::Instant::now();
//     cqrs_service
//         .deposit_money(account_id, Decimal::new(500, 0))
//         .await
//         .expect("Failed to deposit money");
//     let deposit_duration = start_time.elapsed();
//     println!(
//         "âœ… Deposited 500 to account {} in {:?}",
//         account_id, deposit_duration
//     );

//     // Test 3: Withdraw Performance
//     println!("ğŸ’¸ Testing withdraw performance...");
//     let start_time = std::time::Instant::now();
//     cqrs_service
//         .withdraw_money(account_id, Decimal::new(200, 0))
//         .await
//         .expect("Failed to withdraw money");
//     let withdraw_duration = start_time.elapsed();
//     println!(
//         "âœ… Withdrew 200 from account {} in {:?}",
//         account_id, withdraw_duration
//     );

//     // Test 4: Close Account Performance
//     println!("ğŸ”’ Testing close account performance...");
//     let start_time = std::time::Instant::now();
//     cqrs_service
//         .close_account(account_id, "Performance test completion".to_string())
//         .await
//         .expect("Failed to close account");
//     let close_duration = start_time.elapsed();
//     println!("âœ… Closed account {} in {:?}", account_id, close_duration);

//     // Performance Summary
//     println!("ğŸ“Š Performance Summary:");
//     println!("  - Account Creation: {:?}", create_duration);
//     println!("  - Deposit Operation: {:?}", deposit_duration);
//     println!("  - Withdraw Operation: {:?}", withdraw_duration);
//     println!("  - Close Account: {:?}", close_duration);
//     println!(
//         "  - Total Operations Time: {:?}",
//         create_duration + deposit_duration + withdraw_duration + close_duration
//     );

//     // Verify account is closed
//     let account = cqrs_service
//         .get_account(account_id)
//         .await
//         .expect("Failed to get account");
//     assert!(
//         account.is_none() || !account.unwrap().is_active,
//         "Account should be closed"
//     );

//     println!("âœ… All Write Operations Performance Test completed!");
// }
