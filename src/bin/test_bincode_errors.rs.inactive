use anyhow::Result;
use banking_es::domain::{Account, AccountEvent};
use bincode;
use rust_decimal_macros::dec;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<()> {
    println!("🧪 Testing bincode serialization/deserialization errors...");

    // Test 1: Normal serialization/deserialization
    println!("\n📝 Test 1: Normal account serialization");
    let account = Account {
        id: Uuid::new_v4(),
        owner_name: "Test User".to_string(),
        balance: dec!(1000.50),
        is_active: true,
        version: 1,
    };

    // Serialize account
    let serialized = bincode::serialize(&account)?;
    println!(
        "✅ Account serialized successfully: {} bytes",
        serialized.len()
    );

    // Deserialize account
    let deserialized: Account = bincode::deserialize(&serialized)?;
    println!("✅ Account deserialized successfully: {:?}", deserialized);
    assert_eq!(deserialized.id, account.id);
    assert_eq!(deserialized.owner_name, account.owner_name);

    // Test 2: Corrupted data handling
    println!("\n📝 Test 2: Corrupted data handling");
    let corrupted_data = b"this_is_not_valid_bincode_data";

    match bincode::deserialize::<Account>(corrupted_data) {
        Ok(_) => {
            println!("❌ Unexpectedly deserialized corrupted data");
        }
        Err(e) => {
            println!("✅ Correctly handled corrupted data: {:?}", e);
        }
    }

    // Test 3: Events serialization/deserialization
    println!("\n📝 Test 3: Events serialization");
    let events = vec![
        AccountEvent::AccountCreated {
            account_id: Uuid::new_v4(),
            owner_name: "Event Test User".to_string(),
            initial_balance: dec!(500.00),
        },
        AccountEvent::MoneyDeposited {
            account_id: Uuid::new_v4(),
            amount: dec!(100.00),
            transaction_id: Uuid::new_v4(),
        },
    ];

    // Serialize events
    let serialized_events = bincode::serialize(&events)?;
    println!(
        "✅ Events serialized successfully: {} bytes",
        serialized_events.len()
    );

    // Deserialize events
    let deserialized_events: Vec<AccountEvent> = bincode::deserialize(&serialized_events)?;
    println!(
        "✅ Events deserialized successfully: {} events",
        deserialized_events.len()
    );
    assert_eq!(deserialized_events.len(), 2);

    // Test 4: Corrupted events data
    println!("\n📝 Test 4: Corrupted events data handling");
    let corrupted_events_data = b"this_is_not_valid_bincode_events_data";

    match bincode::deserialize::<Vec<AccountEvent>>(corrupted_events_data) {
        Ok(_) => {
            println!("❌ Unexpectedly deserialized corrupted events data");
        }
        Err(e) => {
            println!("✅ Correctly handled corrupted events data: {:?}", e);
        }
    }

    // Test 5: Different data types
    println!("\n📝 Test 5: Different data type handling");
    let string_data = "this_is_a_string_not_an_account";
    let serialized_string = bincode::serialize(string_data)?;

    match bincode::deserialize::<Account>(&serialized_string) {
        Ok(_) => {
            println!("❌ Unexpectedly deserialized string as Account");
        }
        Err(e) => {
            println!("✅ Correctly handled type mismatch: {:?}", e);
        }
    }

    println!("\n✅ Bincode error handling test completed successfully!");
    Ok(())
}
